JavaScript引擎有一个在行末自动添加分号的机制

在JavaScript的世界里，一切都是对象。

但是某些对象还是和其他对象不太一样。为了区分对象的类型，我们用typeof操作符获取对象的类型，它总是返回一个字符串：
typeof 123; // 'number'
typeof NaN; // 'number'
typeof 'str'; // 'string'
typeof true; // 'boolean'
typeof undefined; // 'undefined'
typeof Math.abs; // 'function'
typeof null; // 'object'
typeof []; // 'object'
typeof {}; // 'object'

可见，number、string、boolean、function和undefined有别于其他类型。特别注意null的类型是object，Array的类型也是object，如果我们用typeof将无法区分出null、Array和通常意义上的object——{}。

除了这些类型外，JavaScript还提供了包装对象，熟悉Java的小伙伴肯定很清楚int和Integer这种暧昧关系。

number、boolean和string都有包装对象。没错，在JavaScript中，字符串也区分string类型和它的包装类型。包装对象用new创建：

var n = new Number(123); // 123,生成了新的包装类型
var b = new Boolean(true); // true,生成了新的包装类型
var s = new String('str'); // 'str',生成了新的包装类型

虽然包装对象看上去和原来的值一模一样，显示出来也是一模一样，但他们的类型已经变为object了！所以，包装对象和原始值用===比较会返回false：

typeof new Number(123); // 'object'
new Number(123) === 123; // false

typeof new Boolean(true); // 'object'
new Boolean(true) === true; // false

typeof new String('str'); // 'object'
new String('str') === 'str'; // false

所以闲的蛋疼也不要使用包装对象！尤其是针对string类型！！！

如果我们在使用Number、Boolean和String时，没有写new会发生什么情况？

此时，Number()、Boolean和String()被当做普通函数，把任何类型的数据转换为number、boolean和string类型（注意不是其包装类型）：

var n = Number('123'); // 123，相当于parseInt()或parseFloat()
typeof n; // 'number'

var b = Boolean('true'); // true
typeof b; // 'boolean'

var b2 = Boolean('false'); // true! 'false'字符串转换结果为true！因为它是非空字符串！
var b3 = Boolean(''); // false

var s = String(123.45); // '123.45'
typeof s; // 'string'

总结一下，有这么几条规则需要遵守：
-> 不要使用new Number()、new Boolean()、new String()创建包装对象；
-> 用parseInt()或parseFloat()来转换任意类型到number；
-> 用String()来转换任意类型到string，或者直接调用某个对象的toString()方法；
-> 通常不必把任意类型转换为boolean再判断，因为可以直接写if (myVar) {...}；
-> typeof操作符可以判断出number、boolean、string、function和undefined；
-> 判断Array要使用Array.isArray(arr)；
-> 判断null请使用myVar === null；
-> 判断某个全局变量是否存在用typeof window.myVar === 'undefined'；
-> 函数内部判断某个变量是否存在用typeof myVar === 'undefined'。

最后有细心的同学指出，任何对象都有toString()方法吗？null和undefined就没有！确实如此，这两个特殊值要除外，虽然null还伪装成了object类型。

更细心的同学指出，number对象调用toString()报SyntaxError：
123.toString(); // SyntaxError
遇到这种情况，要特殊处理一下：
123..toString(); // '123', 注意是两个点！
(123).toString(); // '123'
不要问为什么，这就是JavaScript代码的乐趣！

(
	一般对象的toString()方法只能返回个"[object Object]"
	
	1.JavaScript一切皆对象，对象分类型，typeof 返回的是字符串 数组用Array.isArray() null 用=== undefind检测变量是否定义 
	2.Array有slice,splice,concat,join,indexof map,reduce,filter sort(直接根据比较结果排序，把所有元素转化为字符串，字符串根据ASCII码排)
	3.闭包是携带状态的函数，返回的函数没有立即调用，所以不能使用可能改变的变量，返回的函数记录了外部函数的参数和局部变量。 
	4.function* 生成器函数返回生成器对象，然后通过多次调用yield返回值，也是记录状态的函数。 
	5.除了null,undefind外都有toString方法 
	6.避免语法冲突，例如匿名函数调用时要加（）,(123).toString 
	7.Arrow function 是匿名函数 两种形式 this已经定带词法作用域（自动绑定）。
	8.函数定义有两种形式 函数单独调用this指向undefined或者window（非strict）,函数对象调用apply和call方法绑带this（手动绑定） 
	9，const let 定义块级作用域 var 声明的变量在函数内部就是函数作用域，全局变量都绑定在window上。 10.解构赋值多个变量数组需要用[],一般对象用{}括好，可以缺省，可以有默认值，可以当参数接收对象类对象，Array对象 
	11.for in 遍历对象属性 for of，forEach遍历集合对象，map对应的是entry 
	12,对象类对象键值默认只能是字符串，新类型Map的键值可以是其他类型 
	13,iterable类型的forEach，Array的filer的回调函数有三个参数，元素，索引，self 14.函数可以接受任意个变量，可以不定义参数，通过agruements（不是数组，类似）获取变量值。...rest可变参数（以数组的形式接收） 
	15.包装对象类型是object 
	
	3.14.toString();   // "3.14"
	3.14..toString();  // SyntaxError，报错了
	
	因为第一个点是指小数点，第二个点才是调用toString()方法，所以3.14不需要用两个点调用toString()方法
	
	http://www.zuojj.com/archives/888.html 看看这个文章就懂了
	
	可能是已经有了小数点的，用一次点调用就行了。否则用两次。
	
	判断全局对象 用typeof window.myVar === 'undefined' 这里写错了吧 undefined 不允许用'' , 直接裸写就好了啊 不然你这个是字符串了啊
	
	typeof返回值就是字符串
	typeof window  // "object"
	typeof xyz  // "undefined"
	typeof(typeof window)  // "string"
	
	e你说的对的 可是 为什么要多用一个typeof呢
	直接用 === undefined 不就好了?

	假设变量是abc：
	如果变量不存在，下面的代码会报错：
	if (abc === undefined) {} // Uncaught ReferenceError: abc is not defined
	改成：
	if (typeof abc === 'undefined') {} // ok，不会报错
	这是判断一个变量是否已定义的方法
)

数据类型：
Number： 123, 0.456, 1.2345e6(1.2345x1000,即1234.5), -99, NaN(Not a Number，当无法计算结果时用NaN表示), Infinity
		2 / 0; // Infinity
		0 / 0; // NaN
		isNaN('foo') //true, isNaN(NaN) //true 很明显"foo"不是一个数字，它也不是NaN，这是自JavaScrip问世以来就一直存在的bug
		ES6有个工具函数是Number.isNaN()
		var a = 2 / "foo"; var b = "foo";
		Number.isNaN(a);// true Number.isNaN(b);// false
		语言规范是不区分int和float的：
		parseInt('1') === parseFloat('1.0') // true
		但是浏览器执行js时底层区分int／float是为了优化速度
字符串  
		如果字符串内部既包含'又包含"怎么办？可以用转义字符\来标识，比如：'I\'m \"OK\"!';
		var s = 'Hello, world!';
		s[0]; // 'H'
		需要特别注意的是，字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果：
		s[0] = 'h'; s  // 'Hello, world!';
		字符串常用方法，注意，调用这些方法本身不会改变原有字符串的内容，而是返回一个新字符串
		var s = 'Hello';
		s.toUpperCase(); // 'HELLO'
		s.toLowerCase(); // 'hello'
		s.indexOf('e');  // 1
		s.substring(0,2);  //从索引0开始到2（不包括2），返回"He"
		.substring(2); // 从索引2开始到结束，返回'llo'	
布尔值 
		false == 0; // true
		===比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较
		NaN === NaN; // false
		唯一能判断NaN的方法是通过isNaN()函数：isNaN(NaN); // true
		注意浮点数的相等比较：1 / 3 === (1 - 2 / 3); // false
		这不是JavaScript的设计缺陷。浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值
		Math.abs(1 / 3 - (1 - 2 / 3)) < 0.0000001; // true
null
undefined  大多数情况下，我们都应该用null。undefined仅仅在判断函数参数是否传递的情况下有用
对象    []有序集合, {}无序集合
		变量名是大小写英文、数字、$和_的组合，且不能用数字开头。变量名也不能是JavaScript的关键字
		这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下：int a = 123;
		'use strict';
		要取得Array的长度，直接访问length属性。但直接给Array的length赋一个新的值会导致Array大小的变化。
		Array可以通过索引把对应的元素修改为新的值，因此，对Array的索引进行赋值会直接修改这个Array。
		如果通过索引赋值时，索引超过了范围，同样会引起Array大小的变化。
		Array也可以通过indexOf()来搜索一个指定的元素的位置：
		var arr = [10, 20, '30', 'xyz'];
		arr.indexOf(10); // 元素10的索引为0
		slice()就是对应String的substring()版本，它截取Array的部分元素，然后返回一个新的Array：
		var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];
		arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C']
		arr.slice(3); // 从索引3开始到结束: ['D', 'E', 'F', 'G']
		pop()则把Array的最后一个元素删除掉，返回删除掉的元素，原数组变化
		如果要往Array的头部添加若干元素，使用unshift()方法：arr.unshift(1,2), 返回当前数组长度，原数组变化
		shift()方法则把Array的第一个元素删掉，返回删除掉的元素，原数组变化
		sort()可以对当前Array进行排序，它会直接修改当前Array的元素位置，直接调用时，按照默认顺序排序
			var arr = ['B', 'C', 'A'];
			arr.sort();
			arr; // ['A', 'B', 'C']
		reverse()把整个Array的元素给掉个个，也就是反转，原数组变化
		splice()方法是修改Array的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素：
			var arr = ['Microsoft', 'Apple', 'Yahoo', 'AOL', 'Excite', 'Oracle'];
			// 从索引2开始删除3个元素,然后再添加两个元素:
			arr.splice(2, 3, 'Google', 'Facebook'); // 返回删除的元素 ['Yahoo', 'AOL', 'Excite']
			arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']
			// 只删除,不添加:
			arr.splice(2, 2); // ['Google', 'Facebook']
			arr; // ['Microsoft', 'Apple', 'Oracle']
			// 只添加,不删除:
			arr.splice(2, 0, 'Google', 'Facebook'); // 返回[],因为没有删除任何元素
			arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']
		concat()方法把当前的Array和另一个Array连接起来，并返回一个新的Array，原数组不变
			var arr = ['A', 'B', 'C'];
			var added = arr.concat([1, 2, 3]);
			added; // ['A', 'B', 'C', 1, 2, 3]
			arr; // ['A', 'B', 'C']
		实际上，concat()方法可以接收任意个元素和Array，并且自动把Array拆开，拆开一层，然后全部添加到新的Array里
		join()方法是一个非常实用的方法，它把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串，原数组不变
		如果Array的元素不是字符串，将自动转换为字符串后再连接。
		访问属性是通过.操作符完成的，但这要求属性名必须是一个有效的变量名。如果属性名包含特殊字符，就必须用''括起来。访问这个属性也无法使用.操作符，必须用['xxx']来访问
		实际上JavaScript对象的所有属性都是字符串，不过属性对应的值可以是任意数据类型。
		如果访问一个不存在的属性会返回什么呢？JavaScript规定，访问不存在的属性不报错，而是返回undefined。
		delete object.prop  删除对象属性
		如果我们要检测对象是否拥有某一属性，可以用in操作符：
		var person = {name: 'YTon', age: 20, grade: "高三"}
		'name' in person; // true
		'score' in person; // false
		不过要小心，如果in判断一个属性存在，这个属性不一定是person的，它可能是person继承得到的：
		'toString' in person // true
		因为toString定义在object对象中，而所有对象最终都会在原型链上指向object，所以person也拥有toString属性。
		要判断一个属性是否是person自身拥有的，而不是继承得到的，可以用hasOwnProperty()方法:
		person.hasOwnProperty('name'); // true
		person.hasOwnProperty('toString'); // false
		
函数    形参的参数名就是变量名，只有位置有意义，名字无所谓，名字只有一个作用：提高可读性。
        箭头函数相当于匿名函数，并且简化了函数定义。箭头函数有两种格式，一种像上面的，只包含一个表达式，连{ ... }和return都省略掉了。还有一种可以包含多条语句，这时候就不能省略{ ... }和return：
		如果参数不是一个，就需要用括号()括起来：
		// 两个参数:
		(x, y) => x * x + y * y
		// 无参数:
		() => 3.14
		// 可变参数:
		(x, y, ...rest) => {
			var i, sum = x + y;
			for (i=0; i<rest.length; i++) {
				sum += rest[i];
			}
			return sum;
		}
		
		如果要返回一个对象，就要注意，如果是单表达式，这么写的话会报错：

		// SyntaxError:
		x => { foo: x }
		因为和函数体的{ ... }有语法冲突，所以要改为：

		// ok:
		x => ({ foo: x })
		
		箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别：箭头函数内部的this是词法作用域，由上下文确定。
		
		回顾前面的例子，由于JavaScript函数对this绑定的错误处理，下面的例子无法得到预期结果：
		var obj = {
			birth: 1990,
			getAge: function () {
				var b = this.birth; // 1990
				var fn = function () {
					return new Date().getFullYear() - this.birth; // this指向window或undefined
				};
				return fn();
			}
		}
		
		现在，箭头函数完全修复了this的指向，this总是指向词法作用域，也就是外层调用者obj：
		var obj = {
			birth: 1990,
			getAge: function () {
				var b = this.birth; // 1990
				var fn = () => new Date().getFullYear() - this.birth; // this指向obj对象
				return fn();
			}
		};
		obj.getAge(); // 29
		
		如果使用箭头函数，以前的那种hack写法：
		var that = this;
		就不再需要了。
		
		由于this在箭头函数中已经按照词法作用域绑定了，所以，用call()或者apply()调用箭头函数时，无法对this进行绑定，即传入的第一个参数被忽略：
		var obj = {
			birth: 1990,
			getAge: function (year) {
				var b = this.birth; // 1990
				var fn = (y) => y - this.birth; // this.birth仍是1990
				return fn.call({birth:2000}, year);
			}
		};
		obj.getAge(2015); // 25
		
		(
		箭头函数和匿名函数有个明显的区别：箭头函数内部的this是词法作用域，由上下文确定。请问这句话是什么意思？
		
		我理解的是 正经的匿名函数里，this是谁调用它 它就指向谁，但在箭头函数里，谁调用它 它不管，它只看this.xx里的xx是在哪声明的，谁声明的this就指向谁
		
		对象调用里面有this的方法,this指向这个对象;其他情况,this指向window(全局对象).
		)

Map     Map是一组键值对的结构，具有极快的查找速度。
		var m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]);
		m.get('Michael'); // 95
		初始化Map需要一个二维数组，或者直接初始化一个空Map。Map具有以下方法：
		var m = new Map(); // 空Map
		m.set('Adam', 67); // 添加新的key-value
		m.set('Bob', 59);
		m.has('Adam'); // 是否存在key 'Adam': true
		m.get('Adam'); // 67
		m.delete('Adam'); // 删除key 'Adam'
		m.get('Adam'); // undefined
		
		由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：

Set		Set和Map类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key。
		要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set：
		var s1 = new Set(); // 空Set
		var s2 = new Set([1, 2, 3, 3, 4, '4']); // 含1, 2, 3, 4, '4'
		通过add(key)方法可以添加元素到Set中，可以重复添加，但不会有效果：
		s1.add(5);
		s1; // Set {5}
		通过delete(key)方法可以删除元素：
		s1.delete(5);
		s1; // Set {}


var messages = ['1', '2', '3'];
for (var i = 0; i < messages.length; i ++) {
	setTimeout(function(){
		console.log(messages[i]);
	}, i * 1500);
}
将代码放到chrome里使用断点调试和单步调试。由于使用setTimeout;计时功能，当i = 2时，执行时间还未达到设定的时间，i还要执行i++，所以i = 3； message[i]=message[3];由于数组中没有message[3]这个元素，所以显示undefine.

0 === null  //false
0 >= null;  //true
null >= 0;  //true
0 === Number(null);  //true
Number(undefined);  //NaN
Number(null);     //0
NaN === 0;     //false
null === undefined;   //false

循环	if(){...}else{...} 如果语句块只包含一条语句，那么可以省略{}
		请注意，if...else...语句的执行特点是二选一，在多个if...else...语句中，如果某个条件成立，则后续就不再继续判断了。
		JavaScript把null、undefined、0、NaN和空字符串''视为false，其他值一概视为true。

		var height = parseFloat(prompt('请输入身高(m):'));
		var weight = parseFloat(prompt('请输入体重(kg):'));

		利用for循环计算1 * 2 * 3 * ... * 10的结果：
		'use strict';
		...
		if (x === 3628800) {
			console.log('1 x 2 x 3 x ... x 10 = ' + x);
		}
		else {
			console.log('计算错误');
		}
		for循环的3个条件都是可以省略的，如果没有退出循环的判断条件，就必须使用break语句退出循环，否则就是死循环：
		var x = 0;
		for (;;) { // 将无限循环下去
			if (x > 100) {
				break; // 通过if判断来退出循环
			}
			x ++;
		}
		for ... in循环，它可以把一个对象的所有属性依次循环出来
		要过滤掉对象继承的属性，用hasOwnProperty()来实现:
		var obj = {
			name: 'Jack',
			age: 20,
			city: 'Beijing'
		};
		for (var key in obj) {
			if (obj.hasOwnProperty(key)) {
				console.log(key); // 'name', 'age', 'city'
			}
		}
		由于Array也是对象，而它的每个元素的索引被视为对象的属性，因此，for ... in循环可以直接循环出Array的索引：
		var a = ['A', 'B', 'C'];
		for (var i in a) {
			console.log(i); // '0', '1', '2'
			console.log(a[i]); // 'A', 'B', 'C'
		}
		请注意，for ... in对Array的循环得到的是String而不是Number。

		for循环在已知循环的初始和结束条件时非常有用。而上述忽略了条件的for循环容易让人看不清循环的逻辑，此时用while循环更佳。

		while循环只有一个判断条件，条件满足，就不断循环，条件不满足时则退出循环。比如我们要计算100以内所有奇数之和，可以用while循环实现：
		var x = 0;
		var n = 99;
		while (n > 0) {
			x = x + n;
			n = n - 2;
		}
		x; // 2500
		在循环内部变量n不断自减，直到变为-1时，不再满足while条件，循环退出。

		do { ... } while()循环，它和while循环的唯一区别在于，不是在每次循环开始的时候判断条件，而是在每次循环完成的时候判断条件
		var n = 0;
		do {
			n = n + 1;
		} while (n < 100);
		n; // 100
		用do { ... } while()循环要小心，循环体会至少执行1次，而for和while循环则可能一次都不执行。
		请利用循环遍历数组中的每个名字，并显示Hello, xxx!：
		请尝试while循环，并以正序、倒序两种方式遍历。
		'use strict';
		var arr = ['Bart', 'Lisa', 'Adam'];
	
JavaScript的默认对象表示方式{}可以视为其他语言中的Map或Dictionary的数据结构，即一组键值对
但是JavaScript的对象有个小问题，就是键必须是字符串。但实际上Number或者其他数据类型作为键也是非常合理的。

iterable    遍历Array可以采用下标循环，遍历Map和Set就无法使用下标。
			为了统一集合类型，ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型 
		    具有iterable类型的集合可以通过新的for ... of循环来遍历。
			var a = ['A', 'B', 'C'];
			var s = new Set(['A', 'B', 'C']);
			var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);
			for (var x of a) { // 遍历Array
				console.log(x);
			}
			for (var x of s) { // 遍历Set
				console.log(x);
			}
			for (var x of m) { // 遍历Map
				console.log(x[0] + '=' + x[1]);
			}
			
			for ... in循环由于历史遗留问题，它遍历的实际上是对象的属性名称。一个Array数组实际上也是一个对象，它的每个元素的索引被视为一个属性。
			当我们手动给Array对象添加了额外的属性后，for ... in循环将带来意想不到的意外效果：
			var a = ['A', 'B', 'C'];
			a.name = 'Hello';
			for (var x in a) {
				console.log(x); // '0', '1', '2', 'name'
			}
			for ... in循环将把name包括在内，但Array的length属性却不包括在内。
			
			for ... of循环则完全修复了这些问题，它只循环集合本身的元素：
			var a = ['A', 'B', 'C'];
			a.name = 'Hello';
			for (var x of a) {
				console.log(x); // 'A', 'B', 'C'
			}
			这就是为什么要引入新的for ... of循环。

			然而，更好的方式是直接使用iterable内置的forEach方法，它接收一个函数，每次迭代就自动回调该函数。以Array为例：
			'use strict';
			var a = ['A', 'B', 'C'];
			a.forEach(function (element, index, array) {
				// element: 指向当前元素的值
				// index: 指向当前索引
				// array: 指向Array对象本身
				console.log(element + ', index = ' + index);
			});
			
			Set与Array类似，但Set没有索引，因此回调函数的前两个参数都是元素本身：
			var s = new Set(['A', 'B', 'C']);
			s.forEach(function (element, sameElement, set) {
				console.log(element);
			});
			
			Map的回调函数参数依次为value、key和map本身：
			var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);
			m.forEach(function (value, key, map) {
				console.log(value);
			});
			
			
函数    function abs(x) {
			if (x >= 0) {
				return x;
			} else {
				return -x;
			}
		}
		由于JavaScript的函数也是一个对象，上述定义的abs()函数实际上是一个函数对象，而函数名abs可以视为指向该函数的变量
		因此，第二种定义函数的方式如下：
		var abs = function (x) {
			if (x >= 0) {
				return x;
			} else {
				return -x;
			}
		};
		在这种方式下，function (x) { ... }是一个匿名函数，它没有函数名。但是，这个匿名函数赋值给了变量abs，所以，通过变量abs就可以调用该函数。
		上述两种定义完全等价，注意第二种方式按照完整语法需要在函数体末尾加一个;，表示赋值语句结束。
		传入的参数比定义的少也没有问题：abs(); // 返回NaN
		此时abs(x)函数的参数x将收到undefined，计算结果为NaN。
		
		要避免收到undefined，可以对参数进行检查：
		function abs(x) {
			if (typeof x !== 'number') {
				throw 'Not a number';
			}
			if (x >= 0) {
				return x;
			} else {
				return -x;
			}
		}
		
		关键字arguments，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。arguments类似Array但它不是一个Array：
		'use strict'
		function foo(x) {
			console.log('x = ' + x); // 10
			for (var i=0; i<arguments.length; i++) {
				console.log('arg ' + i + ' = ' + arguments[i]); // 10, 20, 30
			}
		}
		foo(10, 20, 30);
		利用arguments，你可以获得调用者传入的所有参数。也就是说，即使函数不定义任何参数，还是可以拿到参数的值：
		function abs() {
			if (arguments.length === 0) {
				return 0;
			}
			var x = arguments[0];
			return x >= 0 ? x : -x;
		}
		
		arguments最常用于判断传入参数的个数。你可能会看到这样的写法：
		// foo(a[, b], c)
		// 接收2~3个参数，b是可选参数，如果只传2个参数，b默认为null：
		function foo(a, b, c) {
			if (arguments.length === 2) {
				// 实际拿到的参数是a和b，c为undefined
				c = b; // 把b赋给c
				b = null; // b变为默认值
			}
			// ...
		}
		要把中间的参数b变为“可选”参数，就只能通过arguments判断，然后重新调整参数并赋值。

		function foo(a, b) {
			var i, rest = [];
			if (arguments.length > 2) {
				for (i = 2; i<arguments.length; i++) {
					rest.push(arguments[i]);
				}
			}
			console.log('a = ' + a);
			console.log('b = ' + b);
			console.log(rest);
		}
		为了获取除了已定义参数a、b之外的参数，我们不得不用arguments，并且循环要从索引2开始以便排除前两个参数，这种写法很别扭，只是为了获得额外的rest参数，有没有更好的方法？
		
		ES6标准引入了rest参数，上面的函数可以改写为：
		function foo(a, b, ...rest) {
			console.log('a = ' + a);
			console.log('b = ' + b);
			console.log(rest);
		}
		foo(1, 2, 3, 4, 5);
		foo(1);
		rest参数只能写在最后，前面用...标识，从运行结果可知，传入的参数先绑定a、b，多余的参数以数组形式交给变量rest，所以，不再需要arguments我们就获取了全部参数。
		如果传入的参数连正常定义的参数都没填满，也不要紧，rest参数会接收一个空数组（注意不是undefined）。
		
		请用rest参数编写一个sum()函数，接收任意个参数并返回它们的和：
		
		// 测试:
		var i, args = [];
		for (i=1; i<=100; i++) {
			args.push(i);
		}
		if (sum() !== 0) {
			console.log('测试失败: sum() = ' + sum());
		} else if (sum(1) !== 1) {
			console.log('测试失败: sum(1) = ' + sum(1));
		} else if (sum(2, 3) !== 5) {
			console.log('测试失败: sum(2, 3) = ' + sum(2, 3));
		} else if (sum.apply(null, args) !== 5050) {
			console.log('测试失败: sum(1, 2, 3, ..., 100) = ' + sum.apply(null, args));
		} else {
			console.log('测试通过!');
		}
		
		function foo() {
			return
				{ name: 'foo' };
		}
		foo(); // undefined
		由于JavaScript引擎在行末自动添加分号的机制，上面的代码实际上变成了：
		function foo() {
			return; // 自动添加了分号，相当于return undefined;
				{ name: 'foo' }; // 这行语句已经没法执行到了
		}
		所以正确的多行写法是：
		function foo() {
			return { // 这里不会自动加分号，因为{表示语句尚未结束
				name: 'foo'
			};
		}
		
		由于JavaScript的函数可以嵌套，此时，内部函数可以访问外部函数定义的变量，反过来则不行。
		如果内部函数和外部函数的变量名重名怎么办？来测试一下：
		'use strict';
		function foo() {
			var x = 1;
			function bar() {
				var x = 'A';
				console.log('x in bar() = ' + x); // 'A'
			}
			console.log('x in foo() = ' + x); // 1
			bar();
		}
		foo();
		这说明JavaScript的函数在查找变量时从自身函数定义开始，从“内”向“外”查找。如果内部函数定义了与外部函数重名的变量，则内部函数的变量将“屏蔽”外部函数的变量。
		
		JavaScript的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部：
		'use strict';
		function foo() {
			var x = 'Hello, ' + y;
			console.log(x);
			var y = 'Bob';
		}
		foo();
		虽然是strict模式，但语句var x = 'Hello, ' + y;并不报错，原因是变量y在稍后申明了。但是console.log显示Hello, undefined，说明变量y的值为undefined。这正是因为JavaScript引擎自动提升了变量y的声明，但不会提升变量y的赋值。
		
		由于JavaScript的这一怪异的“特性”，我们在函数内部定义变量时，请严格遵守“在函数内部首先申明所有变量”这一规则。最常见的做法是用一个var申明函数内部用到的所有变量：

		function foo() {
			var
				x = 1, // x初始化为1
				y = x + 1, // y初始化为2
				z, i; // z和i为undefined
			// 其他语句:
			for (i=0; i<100; i++) {
				...
			}
		}
		
		JavaScript默认有一个全局对象window，全局作用域的变量实际上被绑定到window的一个属性
		
		'use strict';
		var course = 'Learn JavaScript';
		alert(course); // 'Learn JavaScript'
		alert(window.course); // 'Learn JavaScript'
		因此，直接访问全局变量course和访问window.course是完全一样的。

		你可能猜到了，由于函数定义有两种方式，以变量方式var foo = function () {}定义的函数实际上也是一个全局变量，因此，顶层函数的定义也被视为一个全局变量，并绑定到window对象：
		'use strict';
		function foo() {
			alert('foo');
		}
		foo(); // 直接调用foo()
		window.foo(); // 通过window.foo()调用
		
		进一步大胆地猜测，我们每次直接调用的alert()函数其实也是window的一个变量：
		'use strict';
		window.alert('调用window.alert()');
		// 把alert保存到另一个变量:
		var old_alert = window.alert;
		// 给alert赋一个新函数:
		window.alert = function () {}
		alert('无法用alert()显示了!');
		// 恢复alert:
		window.alert = old_alert;
		alert('又可以用alert()了!');
		这说明JavaScript实际上只有一个全局作用域。任何变量（函数也视为变量），如果没有在当前函数作用域中找到，就会继续往上查找，最后如果在全局作用域中也没有找到，则报ReferenceError错误。

		全局变量会绑定到window上，不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突，并且很难被发现。
		减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中。例如：
		// 唯一的全局变量MYAPP:
		var MYAPP = {};
		// 其他变量:
		MYAPP.name = 'myapp';
		MYAPP.version = 1.0;
		// 其他函数:
		MYAPP.foo = function () {
			return 'foo';
		};
		把自己的代码全部放入唯一的名字空间MYAPP中，会大大减少全局变量冲突的可能。
		许多著名的JavaScript库都是这么干的：jQuery，YUI，underscore等等。
		
		由于var和let申明的是变量，如果要申明一个常量，在ES6之前是不行的，我们通常用全部大写的变量来表示“这是一个常量，不要修改它的值”：
		var PI = 3.14;
		ES6标准引入了新的关键字const来定义常量，const与let都具有块级作用域：
		'use strict';
		const PI = 3.14;
		PI = 3; // 某些浏览器不报错，但是无效果！
		PI; // 3.14

		注意，对数组元素进行解构赋值时，多个变量要用[...]括起来。
		如果数组本身还有嵌套，也可以通过下面的形式进行解构赋值，注意嵌套层次和位置要保持一致：
		let [x, [y, z]] = ['hello', ['JavaScript', 'ES6']];
		x; // 'hello'
		y; // 'JavaScript'
		z; // 'ES6'
		
		解构赋值还可以忽略某些元素：
		let [, , z] = ['hello', 'JavaScript', 'ES6']; // 忽略前两个元素，只对z赋值第三个元素
		z; // 'ES6'
		
		如果需要从一个对象中取出若干属性，也可以使用解构赋值，便于快速获取对象的指定属性：
		'use strict';
		var person = {
			name: '小明',
			age: 20,
			gender: 'male',
			passport: 'G-12345678',
			school: 'No.4 middle school'
		};
		var {name, age, passport} = person;
		
		对一个对象进行解构赋值时，同样可以直接对嵌套的对象属性进行赋值，只要保证对应的层次是一致的：
		var person = {
			name: '小明',
			age: 20,
			gender: 'male',
			passport: 'G-12345678',
			school: 'No.4 middle school',
			address: {
				city: 'Beijing',
				street: 'No.1 Road',
				zipcode: '100001'
			}
		};
		var {name, address: {city, zip}} = person;
		name; // '小明'
		city; // 'Beijing'
		zip; // undefined, 因为属性名是zipcode而不是zip
		// 注意: address不是变量，而是为了让city和zip获得嵌套的address对象的属性:
		address; // Uncaught ReferenceError: address is not defined
		
		使用解构赋值对对象属性进行赋值时，如果对应的属性不存在，变量将被赋值为undefined，这和引用一个不存在的属性获得undefined是一致的。如果要使用的变量名和属性名不一致，可以用下面的语法获取：
		var person = {
			name: '小明',
			age: 20,
			gender: 'male',
			passport: 'G-12345678',
			school: 'No.4 middle school'
		};

		// 把passport属性赋值给变量id:
		let {name, passport:id} = person;
		name; // '小明'
		id; // 'G-12345678'
		// 注意: passport不是变量，而是为了让变量id获得passport属性:
		passport; // Uncaught ReferenceError: passport is not defined

		解构赋值还可以使用默认值，这样就避免了不存在的属性返回undefined的问题：
		var person = {
			name: '小明',
			age: 20,
			gender: 'male',
			passport: 'G-12345678'
		};
		// 如果person对象没有single属性，默认赋值为true:
		var {name, single=true} = person;
		name; // '小明'
		single; // true
		
		有些时候，如果变量已经被声明了，再次赋值的时候，正确的写法也会报语法错误：
		// 声明变量:
		var x, y;
		// 解构赋值:
		{x, y} = { name: '小明', x: 100, y: 200};
		// 语法错误: Uncaught SyntaxError: Unexpected token =
		这是因为JavaScript引擎把{开头的语句当作了块处理，于是=不再合法。解决方法是用小括号括起来：
		({x, y} = { name: '小明', x: 100, y: 200});

		解构赋值在很多时候可以大大简化代码。例如，交换两个变量x和y的值，可以这么写，不再需要临时变量：
		var x=1, y=2;
		[x, y] = [y, x]

		快速获取当前页面的域名和路径：
		var {hostname:domain, pathname:path} = location;

		如果一个函数接收一个对象作为参数，那么，可以使用解构直接把对象的属性绑定到变量中。例如，下面的函数可以快速创建一个Date对象：
		function buildDate({year, month, day, hour=0, minute=0, second=0}) {
			return new Date(year + '-' + month + '-' + day + ' ' + hour + ':' + minute + ':' + second);
		}
		它的方便之处在于传入的对象只需要year、month和day这三个属性：
		buildDate({ year: 2017, month: 1, day: 1 });
		// Sun Jan 01 2017 00:00:00 GMT+0800 (CST)
		也可以传入hour、minute和second属性：
		buildDate({ year: 2017, month: 1, day: 1, hour: 20, minute: 15 });
		// Sun Jan 01 2017 20:15:00 GMT+0800 (CST)

		使用解构赋值可以减少代码量，但是，需要在支持ES6解构赋值特性的现代浏览器中才能正常运行

方法	在一个对象中绑定函数，称为这个对象的方法。
		var xiaoming = {
			name: '小明',
			birth: 1990,
			age: function () {
				var y = new Date().getFullYear();
				return y - this.birth;
			}
		};
		xiaoming.age; // function xiaoming.age()
		xiaoming.age(); // 今年调用是29,明年调用就变成30了
		绑定到对象上的函数称为方法，和普通函数也没啥区别，但是它在内部使用了一个this关键字，这个东东是什么？
		在一个方法内部，this是一个特殊变量，它始终指向当前对象，也就是xiaoming这个变量。所以，this.birth可以拿到xiaoming的birth属性。

		让我们拆开写：
		function getAge() {
			var y = new Date().getFullYear();
			return y - this.birth;
		}
		var xiaoming = {
			name: '小明',
			birth: 1990,
			age: getAge
		};
		xiaoming.age(); // 25, 正常结果
		getAge(); // NaN
		单独调用函数getAge()怎么返回了NaN？请注意，我们已经进入到了JavaScript的一个大坑里。
		
		JavaScript的函数内部如果调用了this，那么这个this到底指向谁？
		答案是，视情况而定！
		如果以对象的方法形式调用，比如xiaoming.age()，该函数的this指向被调用的对象，也就是xiaoming，这是符合我们预期的。
		如果单独调用函数，比如getAge()，此时，该函数的this指向全局对象，也就是window。
		坑爹啊！
		
		更坑爹的是，如果这么写：
		var fn = xiaoming.age; // 先拿到xiaoming的age函数
		fn(); // NaN
		也是不行的！要保证this指向正确，必须用obj.xxx()的形式调用！
		
		由于这是一个巨大的设计错误，要想纠正可没那么简单。ECMA决定，在strict模式下让函数的this指向undefined，因此，在strict模式下，你会得到一个错误：
		'use strict';
		var xiaoming = {
			name: '小明',
			birth: 1990,
			age: function () {
				var y = new Date().getFullYear();
				return y - this.birth;
			}
		};
		var fn = xiaoming.age;
		fn(); // Uncaught TypeError: Cannot read property 'birth' of undefined
		这个决定只是让错误及时暴露出来，并没有解决this应该指向的正确位置。
		
		有些时候，喜欢重构的你把方法重构了一下：
		'use strict';
		var xiaoming = {
			name: '小明',
			birth: 1990,
			age: function () {
				function getAgeFromBirth() {
					var y = new Date().getFullYear();
					return y - this.birth;
				}
				return getAgeFromBirth();
			}
		};
		xiaoming.age(); // Uncaught TypeError: Cannot read property 'birth' of undefined
		结果又报错了！原因是this指针只在age方法的函数内指向xiaoming，在函数内部定义的函数，this又指向undefined了！（在非strict模式下，它重新指向全局对象window！）		
		
		修复的办法也不是没有，我们用一个that变量首先捕获this：
		'use strict';
		var xiaoming = {
			name: '小明',
			birth: 1990,
			age: function () {
				var that = this; // 在方法内部一开始就捕获this
				function getAgeFromBirth() {
					var y = new Date().getFullYear();
					return y - that.birth; // 用that而不是this
				}
				return getAgeFromBirth();
			}
		};
		xiaoming.age(); // 29
		用var that = this;，你就可以放心地在方法内部定义其他函数，而不是把所有语句都堆到一个方法中。
		
		虽然在一个独立的函数调用中，根据是否是strict模式，this指向undefined或window，不过，我们还是可以控制this的指向的！
		要指定函数的this指向哪个对象，可以用函数本身的apply方法，它接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array，表示函数本身的参数。
		用apply修复getAge()调用：

		function getAge() {
			var y = new Date().getFullYear();
			return y - this.birth;
		}
		var xiaoming = {
			name: '小明',
			birth: 1990,
			age: getAge
		};
		xiaoming.age(); // 25
		getAge.apply(xiaoming, []); // 25, this指向xiaoming, 参数为空

		另一个与apply()类似的方法是call()，唯一区别是：
			apply()把参数打包成Array再传入；
			call()把参数按顺序传入。

		比如调用Math.max(3, 5, 4)，分别用apply()和call()实现如下：
		Math.max.apply(null, [3, 5, 4]); // 5
		Math.max.call(null, 3, 5, 4); // 5
		对普通函数调用，我们通常把this绑定为null。
		
		利用apply()，我们还可以动态改变函数的行为。
		JavaScript的所有对象都是动态的，即使内置的函数，我们也可以重新指向新的函数。
		
		现在假定我们想统计一下代码一共调用了多少次parseInt()，可以把所有的调用都找出来，然后手动加上count += 1，不过这样做太傻了。最佳方案是用我们自己的函数替换掉默认的parseInt()：
		'use strict';
		var count = 0;
		var oldParseInt = parseInt; // 保存原函数
		window.parseInt = function () {
			count += 1;
			return oldParseInt.apply(null, arguments); // 调用原函数
		};
		// 测试:
		parseInt('10');
		parseInt('20');
		parseInt('30');
		console.log('count = ' + count); // 3
		(   var count = 0;
			window.parseInt = function () {
				return count += 1;
			};
			parseInt('10');
			parseInt('20');
			parseInt('30');
			parseInt('40');
			parseInt('50');
			console.log('count = ' + count);    // 5
			这中间的这些转换操作时为了干什么的，还是我的理解有问题，看完有点蒙

			你这个函数能做什么?? 你传入的参数有意义???? 想一下
			你再看下廖老师的函数计数后运行一下函数等于在原函数基础上加了下功能 重点是没有该改变原函数 重要的事情说三遍没有该改变原函数,没有该改变原函数
			装饰器是设计模式,没有基础或做过软件项目好像有点难以理解,
			慢慢理解,多看几遍,做做项目就懂了
			
			你这样只是完完全全改变的 parseInt() 这个方法的功能，改成了一个针对count变量计数的计数器了，原来的功能没了，所有传不传参没任何意义	
		)
		
		JavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。
		一个最简单的高阶函数：
		function add(x, y, f) {
			return f(x) + f(y);
		}
		当我们调用add(-5, 6, Math.abs)时，参数x，y和f分别接收-5，6和函数Math.abs，根据函数定义，我们可以推导计算过程为：
		x = -5;
		y = 6;
		f = Math.abs;
		f(x) + f(y) ==> Math.abs(-5) + Math.abs(6) ==> 11;
		return 11;
		编写高阶函数，就是让函数的参数能够接收别的函数。
		(   
			其实以我一年的编程经验来看，所谓函数引用、对象引用、函数名其实都是内存中的一个地址，这个地址指向了某个函数或对象或方法，谁拿到了这个地址，谁就拥有了调用函数、调用方法的权利，所以所谓传入函数作为参数，其实就是把这个地址传给了另外一个函数，让另外一个函数拥有操作这个函数的权利，我觉得就是这样，大家觉得呢？
			厉害呀。一年就理解了精髓。我十分赞同贵兄的想法。其实说白了函数代用，就是一个堆地址调用另一个堆地址里指向的函数呀。这也就解释了之前篇章里this的指向问题。佩服佩服
			我觉得这个和C++里面的指针差不多。
			C++ 确实使人理解得更本质更深入
			引用本来就是指向一个地址啊,就是C语言的指针，指针（应该叫指针变量）储存的就是内存地址,如0xffffffff（32位）。C语言里面函数名就是函数的首地址，数组名就是数组的首地址。指针变量本身也有自己的内存地址，占据4字节（这个可能应该根据机器字长而定，32位就是4字节，64为可能指针就是8字节了）。所以C语言里面有数组指针，指针数组，指针的指针的指针的指针的指针（如 int ** p）.....
			
			function add(a) { return function (b) { return a + b; } } add(2)(3)
			
			还可以形象的想一下：A函数拿到了B函数的指针，于是他就可以告诉CPU，“嗨，CPU,你拿着这些参数（A函数的入参实参）到0x7fac91d3bf50(B函数的地址)这个地方去找B，然后带着返回值回来”，嗯，大概就是这样。哈哈
			
			为什么不能写成这样？fuction add(x, y,f()){ return f(x) + f(y); }
			你这些的话，第三个参数就不是函数了，而是一个经过f函数计算出来的值。
			只有写成
			fuction add(x, y,f){ return f(x) + f(y); }
			这样，第三个参数才是函数传递进函数。			
		)
		
		由于map()方法定义在JavaScript的Array中，我们调用Array的map()方法，传入我们自己的函数，就得到了一个新的Array作为结果：
		'use strict';
		function pow(x) {
			return x * x;
		}
		var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
		var results = arr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81]
		console.log(results);
		注意：map()传入的参数是pow，即函数对象本身。

		你可能会想，不需要map()，写一个循环，也可以计算出结果：
		var f = function (x) {
			return x * x;
		};
		var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
		var result = [];
		for (var i=0; i<arr.length; i++) {
			result.push(f(arr[i]));
		}
		的确可以，但是，从上面的循环代码，我们无法一眼看明白“把f(x)作用在Array的每一个元素并把结果生成一个新的Array”。
				
		所以，map()作为高阶函数，事实上它把运算规则抽象了，因此，我们不但可以计算简单的f(x)=x2（x的平方），还可以计算任意复杂的函数，比如，把Array的所有数字转为字符串：
		var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
		arr.map(String); // ['1', '2', '3', '4', '5', '6', '7', '8', '9']
				
		Array的reduce()把一个函数作用在这个Array的[x1, x2, x3...]上，这个函数必须接收两个参数，reduce()把结果继续和序列的下一个元素做累积计算，其效果就是：
		[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)
		
		比方说对一个Array求和，就可以用reduce实现：
		var arr = [1, 3, 5, 7, 9];
		arr.reduce(function (x, y) {
			return x + y;
		}); // 25
		
		练习：利用reduce()求积：
		'use strict';
		function product(arr) {
		...
		}
		// 测试:
		if (product([1, 2, 3, 4]) === 24 && product([0, 1, 2]) === 0 && product([99, 88, 77, 66]) === 44274384) {
			console.log('测试通过!');
		}
		else {
			console.log('测试失败!');
		}
		继续改进这个例子，想办法把一个字符串13579先变成Array——[1, 3, 5, 7, 9]，再利用reduce()就可以写出一个把字符串转换为Number的函数。
		'13579'.split('').map(x => +x).reduce((x,y) => x*10+y)
		'13579'.split('').map(x => x*1).reduce((x,y) => x*10+y)
		
		练习：不要使用JavaScript内置的parseInt()函数，利用map和reduce操作实现一个string2int()函数：
		'use strict';
		function string2int(s) {
		...
		}
		// 测试:
		if (string2int('0') === 0 && string2int('12345') === 12345 && string2int('12300') === 12300) {
			if (string2int.toString().indexOf('parseInt') !== -1) {
				console.log('请勿使用parseInt()!');
			} else if (string2int.toString().indexOf('Number') !== -1) {
				console.log('请勿使用Number()!');
			} else {
				console.log('测试通过!');
			}
		}
		else {
			console.log('测试失败!');
		}
		
		练习: 请把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字。输入：['adam', 'LISA', 'barT']，输出：['Adam', 'Lisa', 'Bart']。
		'use strict';
		function normalize(arr) {
		...
		}	
		// 测试:
		if (normalize(['adam', 'LISA', 'barT']).toString() === ['Adam', 'Lisa', 'Bart'].toString()) {
			console.log('测试通过!');
		}
		else {
			console.log('测试失败!');
		}
		
		['1', '2', '3'].map(parseInt)   // [1, NaN, NaN]
		['1', '2', '3'].map(Number)     // [1, 2, 3]
		https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map
		
		filter也是一个常用的操作，它用于把Array的某些元素过滤掉，然后返回剩下的元素。
		和map()类似，Array的filter()也接收一个函数。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是true还是false决定保留还是丢弃该元素。
		
		例如，在一个Array中，删掉偶数，只保留奇数，可以这么写：
		var arr = [1, 2, 4, 5, 6, 9, 10, 15];
		var r = arr.filter(function (x) {
			return x % 2 !== 0;
		});
		r; // [1, 5, 9, 15]

		把一个Array中的空字符串删掉，可以这么写：
		var arr = ['A', '', 'B', null, undefined, 'C', '  '];
		var r = arr.filter(function (s) {
			return s && s.trim(); // 注意：IE9以下的版本没有trim()方法
		});
		r; // ['A', 'B', 'C']
		
		filter()接收的回调函数，其实可以有多个参数。通常我们仅使用第一个参数，表示Array的某个元素。回调函数还可以接收另外两个参数，表示元素的位置和数组本身：
		var arr = ['A', 'B', 'C'];
		var r = arr.filter(function (element, index, self) {
			console.log(element); // 依次打印'A', 'B', 'C'
			console.log(index); // 依次打印0, 1, 2
			console.log(self); // self就是变量arr
			return true;
		});
		
		利用filter，可以巧妙地去除Array的重复元素：
		'use strict';
		var r,arr = ['apple', 'strawberry', 'banana', 'pear', 'apple', 'orange', 'orange', 'strawberry'];
		r = arr.filter(function (element, index, self) {
			return self.indexOf(element) === index;
		});
		去除重复元素依靠的是indexOf总是返回第一个元素的位置，后续的重复元素位置与indexOf返回的位置不相等，因此被filter滤掉了。
		
		请尝试用filter()筛选出素数：
		'use strict';
		function get_primes(arr) {
			...
			return [];
		}
		// 测试:
		var
			x,
			r,
			arr = [];
		for (x = 1; x < 100; x++) {
			arr.push(x);
		}
		r = get_primes(arr);
		if (r.toString() === [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97].toString()) {
			console.log('测试通过!');
		} else {
			console.log('测试失败: ' + r.toString());
		}
		
		排序也是在程序中经常用到的算法。无论使用冒泡排序还是快速排序，排序的核心是比较两个元素的大小。如果是数字，我们可以直接比较，但如果是字符串或者两个对象呢？直接比较数学上的大小是没有意义的，因此，比较的过程必须通过函数抽象出来。通常规定，对于两个元素x和y，如果认为x < y，则返回-1，如果认为x == y，则返回0，如果认为x > y，则返回1，这样，排序算法就不用关心具体的比较过程，而是根据比较结果直接排序。
		
		JavaScript的Array的sort()方法就是用于排序的，但是排序结果可能让你大吃一惊：
		// 看上去正常的结果:
		['Google', 'Apple', 'Microsoft'].sort(); // ['Apple', 'Google', 'Microsoft'];
		// apple排在了最后:
		['Google', 'apple', 'Microsoft'].sort(); // ['Google', 'Microsoft", 'apple']
		// 无法理解的结果:
		[10, 20, 1, 2].sort(); // [1, 10, 2, 20]
				
		第二个排序把apple排在了最后，是因为字符串根据ASCII码进行排序，而小写字母a的ASCII码在大写字母之后。
		第三个排序结果是什么鬼？简单的数字排序都能错？
		这是因为Array的sort()方法默认把所有元素先转换为String再排序，结果'10'排在了'2'的前面，因为字符'1'比字符'2'的ASCII码小。
				
		如果不知道sort()方法的默认排序规则，直接对数字排序，绝对栽进坑里！
		幸运的是，sort()方法也是一个高阶函数，它还可以接收一个比较函数来实现自定义的排序。
		
		要按数字大小排序，我们可以这么写：
		'use strict';
		var arr = [10, 20, 1, 2];
		arr.sort(function (x, y) {
			if (x < y) {
				return -1;
			}
			if (x > y) {
				return 1;
			}
			return 0;
		});
		console.log(arr); // [1, 2, 10, 20]
		
		如果要倒序排序，我们可以把大的数放前面：
		var arr = [10, 20, 1, 2];
		arr.sort(function (x, y) {
			if (x < y) {
				return 1;
			}
			if (x > y) {
				return -1;
			}
			return 0;
		}); // [20, 10, 2, 1]
		
		默认情况下，对字符串排序，是按照ASCII的大小比较的，现在，我们提出排序应该忽略大小写，按照字母序排序。要实现这个算法，不必对现有代码大加改动，只要我们能定义出忽略大小写的比较算法就可以：
		var arr = ['Google', 'apple', 'Microsoft'];
		arr.sort(function (s1, s2) {
			x1 = s1.toUpperCase();
			x2 = s2.toUpperCase();
			if (x1 < x2) {
				return -1;
			}
			if (x1 > x2) {
				return 1;
			}
			return 0;
		}); // ['apple', 'Google', 'Microsoft']
		忽略大小写来比较两个字符串，实际上就是先把字符串都变成大写（或者都变成小写），再比较。
		
		sort()方法会直接对Array进行修改，它返回的结果仍是当前Array：
		var a1 = ['B', 'A', 'C'];
		var a2 = a1.sort();
		a1; // ['A', 'B', 'C']
		a2; // ['A', 'B', 'C']
		a1 === a2; // true, a1和a2是同一对象
		
		(
			JS的sort并不差，只是对数字排序默认有点坑。
			所有语言的sort都是这么设计：sort(array, fnCompare)，无非是：
			是否修改原数组，还是返回新排序数组
			fnCompare的定义，基本都遵循-1，0，1这个方式。
			
			感觉上一条回的有点蠢。 你想看的应该是http://stackoverflow.com/questions/1494713/how-does-javascripts-sort-work
			看回答，底层实现是JS引擎实现的，包含了多种算法。快排和归并一般都会有。标准没有指明实现必须用哪种算法之类。取决于JS引擎。 不过回答是09年的。供参考。
			
			var arr = [10, 20, 1, 2]; arr.sort(function(a,b){ return a-b;//a-b为升序，b-a为降序 });
			return说明： 返回负数不排序，返回正数排序。
			
			sort()底层由引擎底层实现，你不用关心具体算法。如果是稳定排序，一般是timsort，如果不稳定，一般是快排。
			无论何种排序，传入的compare(x,y)是为了比较两个元素的大小，因为底层排序算法不关心两个元素到底怎么比，由调用方给出比较函数。
			
			我的理解是相邻的两个元素比较，比如升序，x>y 则需要换位置，就返回1。y继续和右边元素比较，大就返回1换位置，小就返回-1位置不变，一直到这个数组第一遍比较完成，然后继续第二遍、第三遍重复上面步骤比较，直到没有返回1需要换位置的。 数组：6，4，3，5，1 第一遍：4，3，5，1，6 第二遍：3，4，1，5，6 第三遍：3，1，4，5，6 第四遍：1，3，4，5，6
			
			嗯，应该是这样。逻辑有点类似于上学时候学C语言时，老师教的冒泡法……
			
			理解是错的，不是冒泡排序
			
			1.sort 函数默认按 ASCII 排序，很多语言都是这样
			2.sort 函数的底层是用 TimSort 算法实现的，这个算法是工业级算法，Python，JAVA 的 sort 函数底层都是这个
			3.**不是冒泡排序！不是冒泡排序！****不是冒泡排序！楼下涉及到冒泡排序实现的都是错的！**别被下面的教程误导！冒泡排序是最简单也是效率最低的算法，除了考试业内没几个人用！
			4.新人学习没有必要纠结为什么这样，你先接受了，有一定的基础再研究为什么，要不然就是钻到牛角尖里了

			之前用过sort,还真没不知道竟然是这样的sort！他会将元素转换为字符串，再根据字符串的第一个字母对应的ASCLL码来排序的。 弄不懂为什么和其他的高阶函数不一样，他直接修改了原数组。
			
			其实就是对数组中的元素就行规范排布，且排序规律那么升，那么降。 arr.sort(function (x, y) {})直接理解成数组中前后两个相邻元素就行。x表示前置位元素，y表示后置位元素，根据x,y的比较三种值，1,0,-1。如果是 x > y 返回1，表示要用前置位元素应当大于后置位元素的排顺序，如果x < y 返回1，表示用后置位元素大于前置位的排序。
			
			我来打脸了： 上面的解释完全错误。看了下其他的评论，发现按“换位置”考虑最靠谱。返回1，表示前后两个相邻元素要换位置，-1和1不换。比如:如果x = 10 ,y = 5 x > y return 1。表示x和y要交换位置，那么就是升序排序。如果x = 10,y = 20 y > x return 1.还是x和y交换位置，表示降序排序。
			
			我觉得是这样理解，欢迎一起讨论 1.计算机的cpu进行大小比较，其实就是运算器将输入的两个二进制做补码减法，再与0比较大小，结果为负表示前者小于后者，反之表示大于 2.sort()这个函数，我只看文章中描述，将所有元素转化成string进行比较，而且仅比较字符串的第一个字符 sort(x,y)中是两个参数相减了与0比较。默认情况是x-y，且排序为升序排序 3.文中直接将x-y的三种情况（小于，相等，大于）抽象成-1，0，1，其实这里-1为任何负数都行，-3，-7，-2018，1为任何正数都行2，3，4，2018，目的是告诉sort（），cpu计算的是对应的哪种情况 所以当想要升序序列，直接默认情况小于返回-1，相等返回0，大于返回1，而想要降序，则小于返回1，相等返回0，大于返回-1（就是将实际cpu计算结果返回相反情况，欺骗sort（）函数） 4.至于字符大小比较也是转化成对应ASCII码进行比较，只不过大小写的编码不同需要统一再比较

			sort和前面讲的reduce不一样。
			sort是定义任意两个元素之间如何比较的算法。arr.sort()时会按照冒泡（或其它）算法每次取数组中特定位置的两个元素进行比较，再取再比较... 直到不需要比较了
			不是像reduce那样就前后两个元素，否则排序不对的...
			
			我看了好久，觉得是不是由返回-1的规则决定排序的顺序，比如 if(a < b) return -1就是前小后大的排列； if(a > b) return -1就是前大后小进行排列。 不知道这样理解对不对，还有，如果只规定返回-1的规则，1，0不指定会有什么影响吗
			
			1 表示交换元素 0 -1不交换,看你想正序还是倒序,自己决定什么时候return 1
			
			想实现将字符串从小到大排在前面，数字从小到大排在后面的排序效果；请问以下代码错误出现在哪
			var arr=[123,11,"ac",10,"xs"];
			arr.sort(function(x,y){
				if(x==NaN&&y!=NaN){
					return -1;
				}
				if(x!=NaN&&y==NaN){
					return 1;
				}
				if(x<y){
					return -1;
				}
				if(x>y){
					return 1;
				}
				return 0;
			})
			console.log(arr); // [11, 123, "ac", 10, "xs"]
			
			NAN不和任何相等，包括它本身
			
			用isNaN()判断就行了
		)
		
		对于数组，除了map()、reduce、filter()、sort()这些方法可以传入一个函数外，Array对象还提供了很多非常实用的高阶函数。
		
		every()方法可以判断数组的所有元素是否满足测试条件
		例如，给定一个包含若干字符串的数组，判断所有字符串是否满足指定的测试条件：
		'use strict';
		var arr = ['Apple', 'pear', 'orange'];
		console.log(arr.every(function (s) {
			return s.length > 0;
		})); // true, 因为每个元素都满足s.length>0
		console.log(arr.every(function (s) {
			return s.toLowerCase() === s;
		})); // false, 因为不是每个元素都全部是小写
		
		find()方法用于查找符合条件的第一个元素，如果找到了，返回这个元素，否则，返回undefined：
		'use strict';
		var arr = ['Apple', 'pear', 'orange'];
		console.log(arr.find(function (s) {
			return s.toLowerCase() === s;
		})); // 'pear', 因为pear全部是小写
		console.log(arr.find(function (s) {
			return s.toUpperCase() === s;
		})); // undefined, 因为没有全部是大写的元素
		
		findIndex()和find()类似，也是查找符合条件的第一个元素，不同之处在于findIndex()会返回这个元素的索引，如果没有找到，返回-1：
		'use strict';
		var arr = ['Apple', 'pear', 'orange'];
		console.log(arr.findIndex(function (s) {
			return s.toLowerCase() === s;
		})); // 1, 因为'pear'的索引是1
		console.log(arr.findIndex(function (s) {
			return s.toUpperCase() === s;
		})); // -1		
		
		forEach()和map()类似，它也把每个元素依次作用于传入的函数，但不会返回新的数组。forEach()常用于遍历数组，因此，传入的函数不需要返回值：
		'use strict';
		var arr = ['Apple', 'pear', 'orange'];
		arr.forEach(console.log); // 依次打印每个元素
		
闭包    函数作为返回值
		高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。
		
		实现一个对Array的求和。通常情况下，求和的函数是这样定义的：
		function sum(arr) {
			return arr.reduce(function (x, y) {
				return x + y;
			});
		}
		sum([1, 2, 3, 4, 5]); // 15
		
		但是，如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办？可以不返回求和的结果，而是返回求和的函数！
		function lazy_sum(arr) {
			var sum = function () {
				return arr.reduce(function (x, y) {
					return x + y;
				});
			}
			return sum;
		}
		当我们调用lazy_sum()时，返回的并不是求和结果，而是求和函数：
		var f = lazy_sum([1, 2, 3, 4, 5]); // function sum()		
		调用函数f时，才真正计算求和的结果：
		f(); // 15
		
		在这个例子中，我们在函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。
		
		请再注意一点，当我们调用lazy_sum()时，每次调用都会返回一个新的函数，即使传入相同的参数：
		
		var f1 = lazy_sum([1, 2, 3, 4, 5]);
		var f2 = lazy_sum([1, 2, 3, 4, 5]);
		f1 === f2; // false
		f1()和f2()的调用结果互不影响。
		
		注意到返回的函数在其定义内部引用了局部变量arr，所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用，所以，闭包用起来简单，实现起来可不容易。

		另一个需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了f()才执行。我们来看一个例子：
		function count() {
			var arr = [];
			for (var i=1; i<=3; i++) {
				arr.push(function () {
					return i * i;
				});
			}
			return arr;
		}
		var results = count();
		var f1 = results[0];
		var f2 = results[1];
		var f3 = results[2];		
		在上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都添加到一个Array中返回了。
		你可能认为调用f1()，f2()和f3()结果应该是1，4，9，但实际结果是：
		f1(); // 16
		f2(); // 16
		f3(); // 16
		全部都是16！原因就在于返回的函数引用了变量i，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量i已经变成了4，因此最终结果为16。
		
		返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。
		
		如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：
		function count() {
			var arr = [];
			for (var i=1; i<=3; i++) {
				arr.push((function (n) {
					return function () {
						return n * n;
					}
				})(i));
			}
			return arr;
		}
		var results = count();
		var f1 = results[0];
		var f2 = results[1];
		var f3 = results[2];
		f1(); // 1
		f2(); // 4
		f3(); // 9	
		
		注意这里用了一个“创建一个匿名函数并立刻执行”的语法：
		(function (x) {
			return x * x;
		})(3); // 9
		
		理论上讲，创建一个匿名函数并立刻执行可以这么写：
		function (x) { return x * x } (3);
		但是由于JavaScript语法解析的问题，会报SyntaxError错误，因此需要用括号把整个函数定义括起来：
		(function (x) { return x * x }) (3);
		
		通常，一个立即执行的匿名函数可以把函数体拆开，一般这么写：
		(function (x) {
			return x * x;
		})(3);
		
		说了这么多，难道闭包就是为了返回一个函数然后延迟执行吗？
		
		当然不是！闭包有非常强大的功能。举个栗子：
		在面向对象的程序设计语言里，比如Java和C++，要在对象内部封装一个私有变量，可以用private修饰一个成员变量。
		在没有class机制，只有函数的语言里，借助闭包，同样可以封装一个私有变量。我们用JavaScript创建一个计数器：
		'use strict';
		function create_counter(initial) {
			var x = initial || 0;
			return {
				inc: function () {
					x += 1;
					return x;
				}
			}
		}
		它用起来像这样：
		var c1 = create_counter();
		c1.inc(); // 1
		c1.inc(); // 2
		c1.inc(); // 3

		var c2 = create_counter(10);
		c2.inc(); // 11
		c2.inc(); // 12
		c2.inc(); // 13
		
		在返回的对象中，实现了一个闭包，该闭包携带了局部变量x，并且，从外部代码根本无法访问到变量x。换句话说，闭包就是携带状态的函数，并且它的状态可以完全对外隐藏起来。
		
		闭包还可以把多参数的函数变成单参数的函数。例如，要计算xy可以用Math.pow(x, y)函数，不过考虑到经常计算x2或x3，我们可以利用闭包创建新的函数pow2和pow3：
		'use strict';
		function make_pow(n) {
			return function (x) {
				return Math.pow(x, n);
			}
		}
		// 创建两个新函数:
		var pow2 = make_pow(2);
		var pow3 = make_pow(3);
		pow2(5); // 25
		pow3(7); // 343
		
		很久很久以前，有个叫阿隆佐·邱奇的帅哥，发现只需要用函数，就可以用计算机实现运算，而不需要0、1、2、3这些数字和+、-、*、/这些符号。
		JavaScript支持函数，所以可以用JavaScript函数来写这些计算。来试试：
		'use strict';
		// 定义数字0:
		var zero = function (f) {
			return function (x) {
				return x;
			}
		};
		// 定义数字1:
		var one = function (f) {
			return function (x) {
				return f(x);
			}
		};
		// 定义加法:
		function add(n, m) {
			return function (f) {
				return function (x) {
					return m(f)(n(f)(x));
				}
			}
		}
		// 计算数字2 = 1 + 1:
		var two = add(one, one);
		// 计算数字3 = 1 + 2:
		var three = add(one, two);
		// 计算数字5 = 2 + 3:
		var five = add(two, three);
		// 你说它是3就是3，你说它是5就是5，你怎么证明？
		// 呵呵，看这里:
		// 给3传一个函数,会打印3次:
		(three(function () {
			console.log('print 3 times');
		}))();
		// 给5传一个函数,会打印5次:
		(five(function () {
			console.log('print 5 times');
		}))();
		// 继续接着玩一会...
		
		(
			function count() { var arr = []; for (var i=1; i<=3; i++) { arr.push(function () { return i * i; }); } return arr; }
			var results = count(); var f1 = results[0]; var f2 = results[1]; var f3 = results[2];
			按照峰哥说的，运行到i=4，此时应该已经退出循环了吧？怎么还会执行arr.push(...){...}？？？麻烦来个大哥解释下，谢谢。
			
			调用f1(),f2(),f3() 前for循环已经执行，arr.push()也执行了，但push()中的function未执行，arr长这样：arr[function,function,function];f1(),f2(),f3() 执行时i等于4了，push中的function执行，arr长这样：arr[16,16,16]。 不知道我理解的对不对。
			
			for循环里的在调用count()函数的时候就已经执行完毕了，for循环里写的代码并不是延迟执行的，是立刻执行的，所以push早就在调用count()函数的时候就已经执行了完毕了。延迟执行的是i*i的这个函数。
			
			i为什么变成4是因为执行到i = 3时，还是会执行i++，可以在循环后面打印i出来看，而i是一个局部变量，最后调用的i是 经过第四次++之后的i。
			let能打印正常应该是let每次都创建了一个新的块作用域吧，每个作用域之间互不影响，这个理解可能有点错误，望指正。
		)
		
generator   一个generator看上去像一个函数，但可以返回多次。
		函数在执行过程中，如果没有遇到return语句（函数末尾如果没有return，就是隐含的return undefined;），控制权无法交回被调用的代码。
		generator跟函数很像，定义如下：
		function* foo(x) {
			yield x + 1;
			yield x + 2;
			return x + 3;
		}
		generator和函数不同的是，generator由function*定义（注意多出的*号），并且，除了return语句，还可以用yield返回多次。
		我们以一个著名的斐波那契数列为例，它由0，1开头：
		0 1 1 2 3 5 8 13 21 34 ...
		要编写一个产生斐波那契数列的函数，可以这么写：
		function fib(max) {
			var
				t,
				a = 0,
				b = 1,
				arr = [0, 1];
			while (arr.length < max) {
				[a, b] = [b, a + b];
				arr.push(b);
			}
			return arr;
		}
		// 测试:
		fib(5); // [0, 1, 1, 2, 3]
		fib(10); // [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
		
		函数只能返回一次，所以必须返回一个Array。但是，如果换成generator，就可以一次返回一个数，不断返回多次。用generator改写如下：
		function* fib(max) {
			var
				t,
				a = 0,
				b = 1,
				n = 0;
			while (n < max) {
				yield a;
				[a, b] = [b, a + b];
				n ++;
			}
			return;
		}
		直接调用试试：
		fib(5); // fib {[[GeneratorStatus]]: "suspended", [[GeneratorReceiver]]: Window}
		直接调用一个generator和调用函数不一样，fib(5)仅仅是创建了一个generator对象，还没有去执行它。
		
		调用generator对象有两个方法，一是不断地调用generator对象的next()方法：
		var f = fib(5);
		f.next(); // {value: 0, done: false}
		f.next(); // {value: 1, done: false}
		f.next(); // {value: 1, done: false}
		f.next(); // {value: 2, done: false}
		f.next(); // {value: 3, done: false}
		f.next(); // {value: undefined, done: true}
		
		next()方法会执行generator的代码，然后，每次遇到yield x;就返回一个对象{value: x, done: true/false}，然后“暂停”。返回的value就是yield的返回值，done表示这个generator是否已经执行结束了。如果done为true，则value就是return的返回值。
		
		当执行到done为true时，这个generator对象就已经全部执行完毕，不要再继续调用next()了
		
		第二个方法是直接用for ... of循环迭代generator对象，这种方式不需要我们自己判断done：
		'use strict'
		function* fib(max) {
			var
				t,
				a = 0,
				b = 1,
				n = 0;
			while (n < max) {
				yield a;
				[a, b] = [b, a + b];
				n ++;
			}
			return;
		}
		for (var x of fib(10)) {
			console.log(x); // 依次输出0, 1, 1, 2, 3, ...
		}
		
		因为generator可以在执行过程中多次返回，所以它看上去就像一个可以记住执行状态的函数，利用这一点，写一个generator就可以实现需要用面向对象才能实现的功能。例如，用一个对象来保存状态，得这么写：
		var fib = {
			a: 0,
			b: 1,
			n: 0,
			max: 5,
			next: function () {
				var
					r = this.a,
					t = this.a + this.b;
				this.a = this.b;
				this.b = t;
				if (this.n < this.max) {
					this.n ++;
					return r;
				} else {
					return undefined;
				}
			}
		};
		用对象的属性来保存状态，相当繁琐。
		generator还有另一个巨大的好处，就是把异步回调代码变成“同步”代码。这个好处要等到后面学了AJAX以后才能体会到。
		
		有了generator的美好时代，用AJAX时可以这么写：
		try {
			r1 = yield ajax('http://url-1', data1);
			r2 = yield ajax('http://url-2', data2);
			r3 = yield ajax('http://url-3', data3);
			success(r3);
		}
		catch (err) {
			handle(err);
		}
		看上去是同步的代码，实际执行是异步的。
		
		要生成一个自增的ID，可以编写一个next_id()函数：
		var current_id = 0;
		function next_id() {
			current_id ++;
			return current_id;
		}
		由于函数无法保存状态，故需要一个全局变量current_id来保存数字。
		不用闭包，试用generator改写：
		'use strict';
		function* next_id() {
			...
		}
		// 测试:
		var
			x,
			pass = true,
			g = next_id();
		for (x = 1; x < 100; x ++) {
			if (g.next().value !== x) {
				pass = false;
				console.log('测试失败!');
				break;
			}
		}
		if (pass) {
			console.log('测试通过!');
		}
		
		(
			function* next_id() {
				var num = 1;
				while(true){
					yield num++;
				}
			}
			
			var id = 1;
			while (1) {
				yield id ++; //为什么首先返回是1不是2?
			}
			
			因为X++是先返回值，再对x做加一操作。如果你用++x就是先加一再返回了。
		)

Date    当前时间是浏览器从本机操作系统获取的时间，所以不一定准确，因为用户可以把当前时间设定为任何值

		你可能观察到了一个非常非常坑爹的地方，就是JavaScript的月份范围用整数表示是0~11，0表示一月，1表示二月……，所以要表示6月，我们传入的是5！这绝对是JavaScript的设计者当时脑抽了一下，但是现在要修复已经不可能了。
		
		JavaScript的Date对象月份值从0开始，牢记0=1月，1=2月，2=3月，……，11=12月。
		
		解析一个符合ISO 8601格式的字符串：
		var d = Date.parse('2015-06-24T19:49:22.875+08:00');   
		d; // 1435146562875
		返回的不是Date对象，而是一个时间戳
		
		var d = new Date(1435146562875);
		d; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)
		d.getMonth(); // 5
		
		使用Date.parse()时传入的字符串使用实际月份01~12，转换为Date对象后getMonth()获取的月份值为0~11。
		
		Date对象表示的时间总是按浏览器所在时区显示的，不过我们既可以显示本地时间，也可以显示调整后的UTC时间：
		var d = new Date(1435146562875);
		d.toLocaleString(); // '2015/6/24 下午7:49:22'，本地时间（北京时区+8:00），显示的字符串与操作系统设定的格式有关
		d.toUTCString(); // 'Wed, 24 Jun 2015 11:49:22 GMT'，UTC时间，与本地时间相差8小时
		
		那么在JavaScript中如何进行时区转换呢？实际上，只要我们传递的是一个number类型的时间戳，我们就不用关心时区转换。任何浏览器都可以把一个时间戳正确转换为本地时间。

		时间戳是个什么东西？时间戳是一个自增的整数，它表示从1970年1月1日零时整的GMT时区开始的那一刻，到现在的毫秒数。假设浏览器所在电脑的时间是准确的，那么世界上无论哪个时区的电脑，它们此刻产生的时间戳数字都是一样的，所以，时间戳可以精确地表示一个时刻，并且与时区无关。
		
		所以，我们只需要传递时间戳，或者把时间戳从数据库里读出来，再让JavaScript自动转换为当地时间就可以了。
		
RegExp  它的设计思想是用一种描述性的语言来给字符串定义一个规则，凡是符合规则的字符串，我们就认为它“匹配”了，否则，该字符串就是不合法的。

		因为正则表达式也是用字符串表示的，所以，我们要首先了解如何用字符来描述字符。

		在正则表达式中，如果直接给出字符，就是精确匹配。用\d可以匹配一个数字，\w可以匹配一个字母或数字，所以：
		'00\d'可以匹配'007'，但无法匹配'00A'；
		'\d\d\d'可以匹配'010'；
		'\w\w'可以匹配'js'；
		
		.可以匹配任意字符，所以：
		'js.'可以匹配'jsp'、'jss'、'js!'等等。
		
		要匹配变长的字符，在正则表达式中，用*表示任意个字符（包括0个），用+表示至少一个字符，用?表示0个或1个字符，用{n}表示n个字符，用{n,m}表示n-m个字符：
		
		来看一个复杂的例子：\d{3}\s+\d{3,8}。
		\d{3}表示匹配3个数字，例如'010'；
		\s可以匹配一个空格（也包括Tab等空白符），所以\s+表示至少有一个空格，例如匹配' '，'\t\t'等；
		\d{3,8}表示3-8个数字，例如'1234567'。
		综合起来，上面的正则表达式可以匹配以任意个空格隔开的带区号的电话号码。
		
		如果要匹配'010-12345'这样的号码呢？由于'-'是特殊字符，在正则表达式中，要用'\'转义，所以，上面的正则是\d{3}\-\d{3,8}。
		
		要做更精确地匹配，可以用[]表示范围，比如：
		->  [0-9a-zA-Z\_] 可以匹配一个数字、字母或者下划线；
		->  [0-9a-zA-Z\_]+ 可以匹配至少由一个数字、字母或者下划线组成的字符串，比如'a100'，'0_Z'，'js2015'等等；
		->  [a-zA-Z\_\$][0-9a-zA-Z\_\$]*可以匹配由字母或下划线、$开头，后接任意个由一个数字、字母或者下划线、$组成的字符串，也就是JavaScript允许的变量名；
		->  [a-zA-Z\_\$][0-9a-zA-Z\_\$]{0, 19}更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）
		
		A|B可以匹配A或B，所以(J|j)ava(S|s)cript可以匹配'JavaScript'、'Javascript'、'javaScript'或者'javascript'。
		
		^表示行的开头，^\d表示必须以数字开头。
		
		$表示行的结束，\d$表示必须以数字结束。
		
		JavaScript有两种方式创建一个正则表达式：(第一种方式是直接通过/正则表达式/写出来，第二种方式是通过new RegExp('正则表达式')创建一个RegExp对象)
		->  /正则表达式/
		->  new RegExp('正则表达式')
		
		两种写法是一样的：
		var re1 = /ABC\-001/;
		var re2 = new RegExp('ABC\\-001');
		
		注意，如果使用第二种写法，因为字符串的转义问题，字符串的两个\\实际上是一个\。
		
		先看看如何判断正则表达式是否匹配：
		var re = /^\d{3}\-\d{3,8}$/;
		re.test('010-12345'); // true
		re.test('010-1234x'); // false
		re.test('010 12345'); // false
		
		RegExp对象的test()方法用于测试给定的字符串是否符合条件。
		
		用正则表达式切分字符串比用固定的字符更灵活，请看正常的切分代码：
		'a b   c'.split(' '); // ['a', 'b', '', '', 'c']
		嗯，无法识别连续的空格，用正则表达式试试：
		'a b   c'.split(/\s+/); // ['a', 'b', 'c']
		
		无论多少个空格都可以正常分割。加入,试试：
		'a,b, c  d'.split(/[\s\,]+/); // ['a', 'b', 'c', 'd']
		
		再加入;试试：
		'a,b;; c  d'.split(/[\s\,\;]+/); // ['a', 'b', 'c', 'd']
		
		如果用户输入了一组标签，下次记得用正则表达式来把不规范的输入转化成正确的数组。
		
		除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用()表示的就是要提取的分组（Group）。比如：
		^(\d{3})-(\d{3,8})$分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：
		var re = /^(\d{3})-(\d{3,8})$/;
		re.exec('010-12345'); // ['010-12345', '010', '12345']
		re.exec('010 12345'); // null
		
		如果正则表达式中定义了组，就可以在RegExp对象上用exec()方法提取出子串来。
		exec()方法在匹配成功后，会返回一个Array，第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串。
		exec()方法在匹配失败时返回null。
		
		提取子串非常有用。来看一个更凶残的例子：
		var re = /^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$/;
		re.exec('19:05:30'); // ['19:05:30', '19', '05', '30']
		这个正则表达式可以直接识别合法的时间。但是有些时候，用正则表达式也无法做到完全验证，比如识别日期：
		var re = /^(0[1-9]|1[0-2]|[0-9])-(0[1-9]|1[0-9]|2[0-9]|3[0-1]|[0-9])$/;
		对于'2-30'，'4-31'这样的非法日期，用正则还是识别不了，或者说写出来非常困难，这时就需要程序配合识别了。
		
		需要特别指出的是，正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的0：
		var re = /^(\d+)(0*)$/;
		re.exec('102300'); // ['102300', '102300', '']
		由于\d+采用贪婪匹配，直接把后面的0全部匹配了，结果0*只能匹配空字符串了。
		
		必须让\d+采用非贪婪匹配（也就是尽可能少匹配），才能把后面的0匹配出来，加个?就可以让\d+采用非贪婪匹配：
		var re = /^(\d+?)(0*)$/;
		re.exec('102300'); // ['102300', '1023', '00']
		
		JavaScript的正则表达式还有几个特殊的标志，最常用的是g，表示全局匹配：
		var r1 = /test/g;
		// 等价于:
		var r2 = new RegExp('test', 'g');
		
		全局匹配可以多次执行exec()方法来搜索一个匹配的字符串。当我们指定g标志后，每次运行exec()，正则表达式本身会更新lastIndex属性，表示上次匹配到的最后索引：

		var s = 'JavaScript, VBScript, JScript and ECMAScript';
		var re=/[a-zA-Z]+Script/g;

		// 使用全局匹配:
		re.exec(s); // ['JavaScript']
		re.lastIndex; // 10

		re.exec(s); // ['VBScript']
		re.lastIndex; // 20

		re.exec(s); // ['JScript']
		re.lastIndex; // 29

		re.exec(s); // ['ECMAScript']
		re.lastIndex; // 44

		re.exec(s); // null，直到结束仍没有匹配到
		全局匹配类似搜索，因此不能使用/^...$/，那样只会最多匹配一次。

		正则表达式还可以指定i标志，表示忽略大小写，m标志，表示执行多行匹配。
				
		请尝试写一个验证Email地址的正则表达式。版本一应该可以验证出类似的Email：
		'use strict';
		var re = /^   $/
		// 测试:
		var
			i,
			success = true,
			should_pass = ['someone@gmail.com', 'bill.gates@microsoft.com', 'tom@voyager.org', 'bob2015@163.com'],
			should_fail = ['test#gmail.com', 'bill@microsoft', 'bill%gates@ms.com', '@voyager.org'];
		for (i = 0; i < should_pass.length; i++) {
			if (!re.test(should_pass[i])) {
				console.log('测试失败: ' + should_pass[i]);
				success = false;
				break;
			}
		}
		for (i = 0; i < should_fail.length; i++) {
			if (re.test(should_fail[i])) {
				console.log('测试失败: ' + should_fail[i]);
				success = false;
				break;
			}
		}
		if (success) {
			console.log('测试通过!');
		}
		版本二可以验证并提取出带名字的Email地址：
		// 测试:
		var r = re.exec('<Tom Paris> tom@voyager.org');
		if (r === null || r.toString() !== ['<Tom Paris> tom@voyager.org', 'Tom Paris', 'tom@voyager.org'].toString()) {
			console.log('测试失败!');
		}
		else {
			console.log('测试成功!');
		}
				
JSON    JSON是JavaScript Object Notation的缩写，它是一种数据交换格式。
		在2002年的一天，道格拉斯·克罗克福特（Douglas Crockford）发明了JSON这种超轻量级的数据交换格式。
		道格拉斯同学长期担任雅虎的高级架构师，自然钟情于JavaScript。他设计的JSON实际上是JavaScript的一个子集。在JSON中，一共就这么几种数据类型：
			number：和JavaScript的number完全一致；
			boolean：就是JavaScript的true或false；
			string：就是JavaScript的string；
			null：就是JavaScript的null；
			array：就是JavaScript的Array表示方式——[]；
			object：就是JavaScript的{ ... }表示方式。
		以及上面的任意组合。
		JSON字符集必须是UTF-8，为了统一解析，JSON的字符串规定必须用双引号""，Object的键也必须用双引号""。
		由于JSON非常简单，很快就风靡Web世界，并且成为ECMA标准。几乎所有编程语言都有解析JSON的库，而在JavaScript中，我们可以直接使用JSON，因为JavaScript内置了JSON的解析。
		把任何JavaScript对象变成JSON，就是把这个对象序列化成一个JSON格式的字符串，这样才能够通过网络传递给其他计算机。
		如果我们收到一个JSON格式的字符串，只需要把它反序列化成一个JavaScript对象，就可以在JavaScript中直接使用这个对象了。
				
序列化	让我们先把小明这个对象序列化成JSON格式的字符串：		
		'use strict';
		var xiaoming = {
			name: '小明',
			age: 14,
			gender: true,
			height: 1.65,
			grade: null,
			'middle-school': '\"W3C\" Middle School',
			skills: ['JavaScript', 'Java', 'Python', 'Lisp']
		};
		var s = JSON.stringify(xiaoming);
		
		要输出得好看一些，可以加上参数，按缩进输出：
		JSON.stringify(xiaoming, null, '  ');
		
		第二个参数用于控制如何筛选对象的键值，如果我们只想输出指定的属性，可以传入Array：
		JSON.stringify(xiaoming, ['name', 'skills'], '  ');
		结果：
		{
		  "name": "小明",
		  "skills": [
			"JavaScript",
			"Java",
			"Python",
			"Lisp"
		  ]
		}
		
		还可以传入一个函数，这样对象的每个键值对都会被函数先处理：
		function convert(key, value) {
			if (typeof value === 'string') {
				return value.toUpperCase();
			}
			return value;
		}
		JSON.stringify(xiaoming, convert, '  ');
		上面的代码把所有属性值都变成大写：
		{
		  "name": "小明",
		  "age": 14,
		  "gender": true,
		  "height": 1.65,
		  "grade": null,
		  "middle-school": "\"W3C\" MIDDLE SCHOOL",
		  "skills": [
			"JAVASCRIPT",
			"JAVA",
			"PYTHON",
			"LISP"
		  ]
		}
		
		如果我们还想要精确控制如何序列化小明，可以给xiaoming定义一个toJSON()的方法，直接返回JSON应该序列化的数据：
		var xiaoming = {
			name: '小明',
			age: 14,
			gender: true,
			height: 1.65,
			grade: null,
			'middle-school': '\"W3C\" Middle School',
			skills: ['JavaScript', 'Java', 'Python', 'Lisp'],
			toJSON: function () {
				return { // 只输出name和age，并且改变了key：
					'Name': this.name,
					'Age': this.age
				};
			}
		};
		JSON.stringify(xiaoming); // '{"Name":"小明","Age":14}'

反序列化	拿到一个JSON格式的字符串，我们直接用JSON.parse()把它变成一个JavaScript对象：
		JSON.parse('[1,2,3,true]'); // [1, 2, 3, true]
		JSON.parse('{"name":"小明","age":14}'); // Object {name: '小明', age: 14}
		JSON.parse('true'); // true
		JSON.parse('123.45'); // 123.45
		
		JSON.parse()还可以接收一个函数，用来转换解析出的属性：
		var obj = JSON.parse('{"name":"小明","age":14}', function (key, value) {
			if (key === 'name') {
				return value + '同学';
			}
			return value;
		});
		console.log(JSON.stringify(obj)); // {name: '小明同学', age: 14}

		(
			为什么网上交换数据需要纯文本格式？不能直接发送二进制Byte吗？
			
			没说一定要纯文本格式啊，懂流的概念吗
			
			最后在链路上传输的就是二进制数据啊，不用json，你自己还是要定一个序列化和反序列化的规则
			
			转换为二进制之前必须要有一定的格式啊，不然对方接到流之后怎么解析？或者你直接手写二进制数据？
		)

面向对象编程
		JavaScript的所有数据都可以看成对象，那是不是我们已经在使用面向对象编程了呢？
		当然不是。如果我们只使用Number、Array、string以及基本的{...}定义的对象，还无法发挥出面向对象编程的威力。

		JavaScript的面向对象编程和大多数其他语言如Java、C#的面向对象编程都不太一样。如果你熟悉Java或C#，很好，你一定明白面向对象的两个基本概念：
			类：类是对象的类型模板，例如，定义Student类来表示学生，类本身是一种类型，Student表示学生类型，但不表示任何具体的某个学生；
			实例：实例是根据类创建的对象，例如，根据Student类可以创建出xiaoming、xiaohong、xiaojun等多个实例，每个实例表示一个具体的学生，他们全都属于Student类型。

		所以，类和实例是大多数面向对象编程语言的基本概念。

		不过，在JavaScript中，这个概念需要改一改。JavaScript不区分类和实例的概念，而是通过原型（prototype）来实现面向对象编程。

		原型是指当我们想要创建xiaoming这个具体的学生时，我们并没有一个Student类型可用。那怎么办？恰好有这么一个现成的对象：
		var robot = {
			name: 'Robot',
			height: 1.6,
			run: function () {
				console.log(this.name + ' is running...');
			}
		};
		我们看这个robot对象有名字，有身高，还会跑，有点像小明，干脆就根据它来“创建”小明得了！
		
		于是我们把它改名为Student，然后创建出xiaoming：
		var Student = {
			name: 'Robot',
			height: 1.2,
			run: function () {
				console.log(this.name + ' is running...');
			}
		};

		var xiaoming = {
			name: '小明'
		};

		xiaoming.__proto__ = Student;

		注意最后一行代码把xiaoming的原型指向了对象Student，看上去xiaoming仿佛是从Student继承下来的：
		xiaoming.name; // '小明'
		xiaoming.run(); // 小明 is running...

		xiaoming有自己的name属性，但并没有定义run()方法。不过，由于小明是从Student继承而来，只要Student有run()方法，xiaoming也可以调用：

		JavaScript的原型链和Java的Class区别就在，它没有“Class”的概念，所有对象都是实例，所谓继承关系不过是把一个对象的原型指向另一个对象而已。
		
		如果你把xiaoming的原型指向其他对象：
		var Bird = {
			fly: function () {
				console.log(this.name + ' is flying...');
			}
		};
		xiaoming.__proto__ = Bird;

		现在xiaoming已经无法run()了，他已经变成了一只鸟：
		xiaoming.fly(); // 小明 is flying...
		
		在JavaScrip代码运行时期，你可以把xiaoming从Student变成Bird，或者变成任何对象。
		
		请注意，上述代码仅用于演示目的。在编写JavaScript代码时，不要直接用obj.__proto__去改变一个对象的原型，并且，低版本的IE也无法使用__proto__。
		
		Object.create()方法可以传入一个原型对象，并创建一个基于该原型的新对象，但是新对象什么属性都没有，因此，我们可以编写一个函数来创建xiaoming：
		// 原型对象:
		var Student = {
			name: 'Robot',
			height: 1.2,
			run: function () {
				console.log(this.name + ' is running...');
			}
		};

		function createStudent(name) {
			// 基于Student原型创建一个新对象:
			var s = Object.create(Student);
			// 初始化新对象:
			s.name = name;
			return s;
		}

		var xiaoming = createStudent('小明');
		xiaoming.run(); // 小明 is running...
		xiaoming.__proto__ === Student; // true

		这是创建原型继承的一种方法，JavaScript还有其他方法来创建对象
		
		JavaScript对每个创建的对象都会设置一个原型，指向它的原型对象。
		当我们用obj.xxx访问一个对象的属性时，JavaScript引擎先在当前对象上查找该属性，如果没有找到，就到其原型对象上找，如果还没有找到，就一直上溯到Object.prototype对象，最后，如果还没有找到，就只能返回undefined。
		
		例如，创建一个Array对象：
		var arr = [1, 2, 3];
		其原型链是：
		arr ----> Array.prototype ----> Object.prototype ----> null
		Array.prototype定义了indexOf()、shift()等方法，因此你可以在所有的Array对象上直接调用这些方法。

		当我们创建一个函数时：
		function foo() {
			return 0;
		}
		函数也是一个对象，它的原型链是：
		foo ----> Function.prototype ----> Object.prototype ----> null
		由于Function.prototype定义了apply()等方法，因此，所有函数都可以调用apply()方法。
		
		很容易想到，如果原型链很长，那么访问一个对象的属性就会因为花更多的时间查找而变得更慢，因此要注意不要把原型链搞得太长。
		
		除了直接用{ ... }创建一个对象外，JavaScript还可以用一种构造函数的方法来创建对象。它的用法是，先定义一个构造函数：
		
		function Student(name) {
			this.name = name;
			this.hello = function () {
				alert('Hello, ' + this.name + '!');
			}
		}
		
		这是一个普通函数，但是在JavaScript中，可以用关键字new来调用这个函数，并返回一个对象：
		
		var xiaoming = new Student('小明');
		xiaoming.name; // '小明'
		xiaoming.hello(); // Hello, 小明!
		注意，如果不写new，这就是一个普通函数，它返回undefined。但是，如果写了new，它就变成了一个构造函数，它绑定的this指向新创建的对象，并默认返回this，也就是说，不需要在最后写return this;。
		
		新创建的xiaoming的原型链是：
		
		xiaoming ----> Student.prototype ----> Object.prototype ----> null
		
		也就是说，xiaoming的原型指向函数Student的原型。如果你又创建了xiaohong、xiaojun，那么这些对象的原型与xiaoming是一样的：
		
		xiaoming ↘
		xiaohong -→ Student.prototype ----> Object.prototype ----> null
		xiaojun  ↗
		
		用new Student()创建的对象还从原型上获得了一个constructor属性，它指向函数Student本身：
		xiaoming.constructor === Student.prototype.constructor; // true
		Student.prototype.constructor === Student; // true
		Object.getPrototypeOf(xiaoming) === Student.prototype; // true
		xiaoming instanceof Student; // true
		
		如图：<a target='blank' href='https://static.liaoxuefeng.com/files/attachments/1024698721053600/l'>https://static.liaoxuefeng.com/files/attachments/1024698721053600/l</a>
		
		红色箭头是原型链。注意，Student.prototype指向的对象就是xiaoming、xiaohong的原型对象，这个原型对象自己还有个属性constructor，指向Student函数本身。
		
		另外，函数Student恰好有个属性prototype指向xiaoming、xiaohong的原型对象，但是xiaoming、xiaohong这些对象可没有prototype这个属性，不过可以用__proto__这个非标准用法来查看。
		
		现在我们就认为xiaoming、xiaohong这些对象“继承”自Student。
		
		不过还有一个小问题，注意观察：

		xiaoming.name; // '小明'
		xiaohong.name; // '小红'
		xiaoming.hello; // function: Student.hello()
		xiaohong.hello; // function: Student.hello()
		xiaoming.hello === xiaohong.hello; // false
		
		xiaoming和xiaohong各自的name不同，这是对的，否则我们无法区分谁是谁了。
		xiaoming和xiaohong各自的hello是一个函数，但它们是两个不同的函数，虽然函数名称和代码都是相同的！
		如果我们通过new Student()创建了很多对象，这些对象的hello函数实际上只需要共享同一个函数就可以了，这样可以节省很多内存。
		要让创建的对象共享一个hello函数，根据对象的属性查找原则，我们只要把hello函数移动到xiaoming、xiaohong这些对象共同的原型上就可以了，也就是Student.prototype：
		
		如图：<a target='blank' href='https://static.liaoxuefeng.com/files/attachments/1024700039819712/l'>https://static.liaoxuefeng.com/files/attachments/1024700039819712/l</a>
		
		修改代码如下：
		function Student(name) {
			this.name = name;
		}
		Student.prototype.hello = function () {
			alert('Hello, ' + this.name + '!');
		};
		
		用new创建基于原型的JavaScript的对象就是这么简单！
		
		如果一个函数被定义为用于创建对象的构造函数，但是调用时忘记了写new怎么办？
		
		在strict模式下，this.name = name将报错，因为this绑定为undefined，在非strict模式下，this.name = name不报错，因为this绑定为window，于是无意间创建了全局变量name，并且返回undefined，这个结果更糟糕。
		
		所以，调用构造函数千万不要忘记写new。为了区分普通函数和构造函数，按照约定，构造函数首字母应当大写，而普通函数首字母应当小写，这样，一些语法检查工具如jslint将可以帮你检测到漏写的new。
		
		最后，我们还可以编写一个createStudent()函数，在内部封装所有的new操作。一个常用的编程模式像这样：
		
		function Student(props) {
			this.name = props.name || '匿名'; // 默认值为'匿名'
			this.grade = props.grade || 1; // 默认值为1
		}
		Student.prototype.hello = function () {
			alert('Hello, ' + this.name + '!');
		};
		function createStudent(props) {
			return new Student(props || {})
		}
		
		createStudent()函数有几个巨大的优点：一是不需要new来调用，二是参数非常灵活，可以不传，也可以这么传：
		
		var xiaoming = createStudent({
			name: '小明'
		});
		xiaoming.grade; // 1
		
		如果创建的对象有很多属性，我们只需要传递需要的某些属性，剩下的属性可以用默认值。由于参数是一个Object，我们无需记忆参数的顺序。如果恰好从JSON拿到了一个对象，就可以直接创建出xiaoming。
		
		练习：请利用构造函数定义Cat，并让所有的Cat对象有一个name属性，并共享一个方法say()，返回字符串'Hello, xxx!'：
		'use strict';
		...
		
		// 测试:
		var kitty = new Cat('Kitty');
		var doraemon = new Cat('哆啦A梦');
		if (kitty && kitty.name === 'Kitty' && kitty.say && typeof kitty.say === 'function' && kitty.say() === 'Hello, Kitty!' && kitty.say === doraemon.say) {
			console.log('测试通过!');
		} else {
			console.log('测试失败!');
		}

		在传统的基于Class的语言如Java、C++中，继承的本质是扩展一个已有的Class，并生成新的Subclass。
		由于这类语言严格区分类和实例，继承实际上是类型的扩展。但是，JavaScript由于采用原型继承，我们无法直接扩展一个Class，因为根本不存在Class这种类型。
		
		但是办法还是有的。我们先回顾Student构造函数：
		function Student(props) {
			this.name = props.name || 'Unnamed';
		}
		Student.prototype.hello = function () {
			alert('Hello, ' + this.name + '!');
		}
		以及Student的原型链：
		如图： https://static.liaoxuefeng.com/files/attachments/1034288810160288/l
		
		现在，我们要基于Student扩展出PrimaryStudent，可以先定义出PrimaryStudent：
		function PrimaryStudent(props) {
			// 调用Student构造函数，绑定this变量:
			Student.call(this, props);
			this.grade = props.grade || 1;
		}
		但是，调用了Student构造函数不等于继承了Student，PrimaryStudent创建的对象的原型是：
		new PrimaryStudent() ----> PrimaryStudent.prototype ----> Object.prototype ----> null
		
		必须想办法把原型链修改为：
		new PrimaryStudent() ----> PrimaryStudent.prototype ----> Student.prototype ----> Object.prototype ----> null
		
		这样，原型链对了，继承关系就对了。新的基于PrimaryStudent创建的对象不但能调用PrimaryStudent.prototype定义的方法，也可以调用Student.prototype定义的方法。
		
		如果你想用最简单粗暴的方法这么干：
		PrimaryStudent.prototype = Student.prototype;
		是不行的！如果这样的话，PrimaryStudent和Student共享一个原型对象，那还要定义PrimaryStudent干啥？

		我们必须借助一个中间对象来实现正确的原型链，这个中间对象的原型要指向Student.prototype。为了实现这一点，参考道爷（就是发明JSON的那个道格拉斯）的代码，中间对象可以用一个空函数F来实现：
		// PrimaryStudent构造函数:
		function PrimaryStudent(props) {
			Student.call(this, props);
			this.grade = props.grade || 1;
		}
		// 空函数F:
		function F() {}
		// 把F的原型指向Student.prototype:
		F.prototype = Student.prototype;
		// 把PrimaryStudent的原型指向一个新的F对象，F对象的原型正好指向Student.prototype:
		PrimaryStudent.prototype = new F();
		// 把PrimaryStudent原型的构造函数修复为PrimaryStudent:
		PrimaryStudent.prototype.constructor = PrimaryStudent;
		// 继续在PrimaryStudent原型（就是new F()对象）上定义方法：
		PrimaryStudent.prototype.getGrade = function () {
			return this.grade;
		};
		// 创建xiaoming:
		var xiaoming = new PrimaryStudent({
			name: '小明',
			grade: 2
		});
		xiaoming.name; // '小明'
		xiaoming.grade; // 2
		// 验证原型:
		xiaoming.__proto__ === PrimaryStudent.prototype; // true
		xiaoming.__proto__.__proto__ === Student.prototype; // true
		// 验证继承关系:
		xiaoming instanceof PrimaryStudent; // true
		xiaoming instanceof Student; // true
		
		用一张图来表示新的原型链：
		如图: https://static.liaoxuefeng.com/files/attachments/1034288859918112/l
		
		注意，函数F仅用于桥接，我们仅创建了一个new F()实例，而且，没有改变原有的Student定义的原型链。
		
		如果把继承这个动作用一个inherits()函数封装起来，还可以隐藏F的定义，并简化代码：
		function inherits(Child, Parent) {
			var F = function () {};
			F.prototype = Parent.prototype;
			Child.prototype = new F();
			Child.prototype.constructor = Child;
		}
		
		这个inherits()函数可以复用：
		function Student(props) {
			this.name = props.name || 'Unnamed';
		}
		Student.prototype.hello = function () {
			alert('Hello, ' + this.name + '!');
		}
		function PrimaryStudent(props) {
			Student.call(this, props);
			this.grade = props.grade || 1;
		}
		// 实现原型继承链:
		inherits(PrimaryStudent, Student);
		// 绑定其他方法到PrimaryStudent原型:
		PrimaryStudent.prototype.getGrade = function () {
			return this.grade;
		};
		
		JavaScript的原型继承实现方式就是：
			定义新的构造函数，并在内部用call()调用希望“继承”的构造函数，并绑定this；
			借助中间函数F实现原型链继承，最好通过封装的inherits函数完成；
			继续在新的构造函数的原型上定义新方法。
		
		(
			prototype是函数的属性
			__proto__是对象的
			
			不推荐Object.prototype.__proto__的原因：
			已废弃
				该特性已经从 Web 标准中删除，虽然一些浏览器目前仍然支持它，但也许会在未来的某个时间停止支持，请尽量不要使用该特性。
			警告: 通过现代浏览器的操作属性的便利性，可以改变一个对象的 [[Prototype]] 属性, 这种行为在每一个JavaScript引擎和浏览器中都是一个非常慢且影响性能的操作，使用这种方式来改变和继承属性是对性能影响非常严重的，并且性能消耗的时间也不是简单的花费在 obj.__proto__ = ... 语句上, 它还会影响到所有继承来自该 [[Prototype]] 的对象，如果你关心性能，你就不应该在一个对象中修改它的 [[Prototype]]。相反, 创建一个新的且可以继承 [[Prototype]] 的对象，推荐使用 Object.create()。
			警告: 当Object.prototype.__proto__ 已被大多数浏览器厂商所支持的今天，其存在和确切行为仅在ECMAScript 2015规范中被标准化为传统功能，以确保Web浏览器的兼容性。为了更好的支持，建议只使用 Object.getPrototypeOf()。
			参考链接<a href='https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/proto'>https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/proto</a>
		)
		
		
		在上面的章节中我们看到了JavaScript的对象模型是基于原型实现的，特点是简单，缺点是理解起来比传统的类－实例模型要困难，最大的缺点是继承的实现需要编写大量代码，并且需要正确实现原型链。
		有没有更简单的写法？有！

		新的关键字class从ES6开始正式被引入到JavaScript中。class的目的就是让定义类更简单。
		
		我们先回顾用函数实现Student的方法：
		function Student(name) {
			this.name = name;
		}
		Student.prototype.hello = function () {
			alert('Hello, ' + this.name + '!');
		}
		
		如果用新的class关键字来编写Student，可以这样写：
		class Student {
			constructor(name) {
				this.name = name;
			}
			hello() {
				alert('Hello, ' + this.name + '!');
			}
		}
		比较一下就可以发现，class的定义包含了构造函数constructor和定义在原型对象上的函数hello()（注意没有function关键字），这样就避免了Student.prototype.hello = function () {...}这样分散的代码。

		最后，创建一个Student对象代码和前面章节完全一样：
		var xiaoming = new Student('小明');
		xiaoming.hello();
		
		用class定义对象的另一个巨大的好处是继承更方便了。想一想我们从Student派生一个PrimaryStudent需要编写的代码量。现在，原型继承的中间对象，原型对象的构造函数等等都不需要考虑了，直接通过extends来实现：
		class PrimaryStudent extends Student {
			constructor(name, grade) {
				super(name); // 记得用super调用父类的构造方法!
				this.grade = grade;
			}
			myGrade() {
				alert('I am at grade ' + this.grade);
			}
		}
		
		注意PrimaryStudent的定义也是class关键字实现的，而extends则表示原型链对象来自Student。子类的构造函数可能会与父类不太相同，例如，PrimaryStudent需要name和grade两个参数，并且需要通过super(name)来调用父类的构造函数，否则父类的name属性无法正常初始化。
		
		PrimaryStudent已经自动获得了父类Student的hello方法，我们又在子类中定义了新的myGrade方法。

		ES6引入的class和原有的JavaScript原型继承有什么区别呢？实际上它们没有任何区别，class的作用就是让JavaScript引擎去实现原来需要我们自己编写的原型链代码。简而言之，用class的好处就是极大地简化了原型链代码。

		你一定会问，class这么好用，能不能现在就用上？

		现在用还早了点，因为不是所有的主流浏览器都支持ES6的class。如果一定要现在就用上，就需要一个工具把class代码转换为传统的prototype代码，可以试试Babel这个工具。

		练习: 请利用class重新定义Cat，并让它从已有的Animal继承，然后新增一个方法say()，返回字符串'Hello, xxx!'：
		'use strict';
		class Animal {
			constructor(name) {
				this.name = name;
			}
		}
		...
		// 测试:
		var kitty = new Cat('Kitty');
		var doraemon = new Cat('哆啦A梦');
		if ((new Cat('x') instanceof Animal) && kitty && kitty.name === 'Kitty' && kitty.say && typeof kitty.say === 'function' && kitty.say() === 'Hello, Kitty!' && kitty.say === doraemon.say) {
			console.log('测试通过!');
		} else {
			console.log('测试失败!');
		}
		这个练习需要浏览器支持ES6的class，如果遇到SyntaxError，则说明浏览器不支持class语法，请换一个最新的浏览器试试。
		
		(
			class Cat extends Animal{ say(){ return "Hello, " + this.name+"!"; } }
			
			class Cat extends Animal{ constructor(name){ super(name); }
			say(){ return "Hello, "+{this.name}+"!"; } }
			这两种写法有什么不同，都能执行出来
			
			如果没有显式指定构造方法，则会自动添加默认的constructor方法。
			对于基类的默认构造方法为
			constructor() {}
			对于派生类的默认构造方法为
			constructor(...args) {
			  super(...args);
			}
		)
		
目前主流的浏览器分这么几种：
	IE 6~11：国内用得最多的IE浏览器，历来对W3C标准支持差。从IE10开始支持ES6标准；
	Chrome：Google出品的基于Webkit内核浏览器，内置了非常强悍的JavaScript引擎——V8。由于Chrome一经安装就时刻保持自升级，所以不用管它的版本，最新版早就支持ES6了；
	Safari：Apple的Mac系统自带的基于Webkit内核的浏览器，从OS X 10.7 Lion自带的6.1版本开始支持ES6，目前最新的OS X 10.11 El Capitan自带的Safari版本是9.x，早已支持ES6；
	Firefox：Mozilla自己研制的Gecko内核和JavaScript引擎OdinMonkey。早期的Firefox按版本发布，后来终于聪明地学习Chrome的做法进行自升级，时刻保持最新；
	移动设备上目前iOS和Android两大阵营分别主要使用Apple的Safari和Google的Chrome，由于两者都是Webkit核心，结果HTML5首先在手机上全面普及（桌面绝对是Microsoft拖了后腿），对JavaScript的标准支持也很好，最新版本均支持ES6。
		
	其他浏览器如Opera等由于市场份额太小就被自动忽略了。
	另外还要注意识别各种国产浏览器，如某某安全浏览器，某某旋风浏览器，它们只是做了一个壳，其核心调用的是IE，也有号称同时支持IE和Webkit的“双核”浏览器。	
		
	window对象不但充当全局作用域，而且表示浏览器窗口。
	window对象有innerWidth和innerHeight属性，可以获取浏览器窗口的内部宽度和高度。内部宽高是指除去菜单栏、工具栏、边框等占位元素后，用于显示网页的净宽高。

	兼容性：IE<=8不支持
	'use strict';
	// 可以调整浏览器窗口大小试试:
	console.log('window inner size: ' + window.innerWidth + ' x ' + window.innerHeight);

	对应的，还有一个outerWidth和outerHeight属性，可以获取浏览器窗口的整个宽高。
	
	navigator对象表示浏览器的信息，最常用的属性包括：
		navigator.appName：浏览器名称；
		navigator.appVersion：浏览器版本；
		navigator.language：浏览器设置的语言；
		navigator.platform：操作系统类型；
		navigator.userAgent：浏览器设定的User-Agent字符串。
	
	'use strict';
	console.log('appName = ' + navigator.appName);
	console.log('appVersion = ' + navigator.appVersion);
	console.log('language = ' + navigator.language);
	console.log('platform = ' + navigator.platform);
	console.log('userAgent = ' + navigator.userAgent);

	请注意，navigator的信息可以很容易地被用户修改，所以JavaScript读取的值不一定是正确的。很多初学者为了针对不同浏览器编写不同的代码，喜欢用if判断浏览器版本，例如：
	var width;
	if (getIEVersion(navigator.userAgent) < 9) {
		width = document.body.clientWidth;
	} else {
		width = window.innerWidth;
	}
	但这样既可能判断不准确，也很难维护代码。正确的方法是充分利用JavaScript对不存在属性返回undefined的特性，直接用短路运算符||计算：
	var width = window.innerWidth || document.body.clientWidth;

	screen对象表示屏幕的信息，常用的属性有：
		screen.width：屏幕宽度，以像素为单位；
		screen.height：屏幕高度，以像素为单位；
		screen.colorDepth：返回颜色位数，如8、16、24。
	'use strict';
	console.log('Screen size = ' + screen.width + ' x ' + screen.height);
	
	location对象表示当前页面的URL信息。例如，一个完整的URL：
	http://www.example.com:8080/path/index.html?a=1&b=2#TOP
	可以用location.href获取。要获得URL各个部分的值，可以这么写：
	location.protocol; // 'http'
	location.host; // 'www.example.com'
	location.port; // '8080'
	location.pathname; // '/path/index.html'
	location.search; // '?a=1&b=2'
	location.hash; // 'TOP'
	
	要加载一个新页面，可以调用location.assign()。如果要重新加载当前页面，调用location.reload()方法非常方便。
	'use strict';
	if (confirm('重新加载当前页' + location.href + '?')) {
		location.reload();
	} else {
		location.assign('/'); // 设置一个新的URL地址
	}
	
	document对象表示当前页面。由于HTML在浏览器中以DOM形式表示为树形结构，document对象就是整个DOM树的根节点。
	document的title属性是从HTML文档中的<title>xxx</title>读取的，但是可以动态改变：
	'use strict';
	document.title = '努力学习JavaScript!';
	
	要查找DOM树的某个节点，需要从document对象开始查找。最常用的查找是根据ID和Tag Name。
	
	用document对象提供的getElementById()和getElementsByTagName()可以按ID获得一个DOM节点和按Tag名称获得一组DOM节点(即数组)
	
	document对象还有一个cookie属性，可以获取当前页面的Cookie。

	Cookie是由服务器发送的key-value标示符。因为HTTP协议是无状态的，但是服务器要区分到底是哪个用户发过来的请求，就可以用Cookie来区分。当一个用户成功登录后，服务器发送一个Cookie给浏览器，例如user=ABC123XYZ(加密的字符串)...，此后，浏览器访问该网站时，会在请求头附上这个Cookie，服务器根据Cookie即可区分出用户。

	Cookie还可以存储网站的一些设置，例如，页面显示的语言等等。

	JavaScript可以通过document.cookie读取到当前页面的Cookie：document.cookie; 
	
	由于JavaScript能读取到页面的Cookie，而用户的登录信息通常也存在Cookie中，这就造成了巨大的安全隐患，这是因为在HTML页面中引入第三方的JavaScript代码是允许的：

	<!-- 当前页面在www.example.com -->
	<html>
		<head>
			<script src="http://www.foo.com/jquery.js"></script>
		</head>
		...
	</html>
	如果引入的第三方的JavaScript中存在恶意代码，则www.foo.com网站将直接获取到www.example.com网站的用户登录信息。
	
	为了解决这个问题，服务器在设置Cookie时可以使用httpOnly，设定了httpOnly的Cookie将不能被JavaScript读取。这个行为由浏览器实现，主流浏览器均支持httpOnly选项，IE从IE6 SP1开始支持。

	为了确保安全，服务器端在设置Cookie时，应该始终坚持使用httpOnly。
	
	history对象保存了浏览器的历史记录，JavaScript可以调用history对象的back()或forward ()，相当于用户点击了浏览器的“后退”或“前进”按钮。
	这个对象属于历史遗留对象，对于现代Web页面来说，由于大量使用AJAX和页面交互，简单粗暴地调用history.back()可能会让用户感到非常愤怒。
	新手开始设计Web页面时喜欢在登录页登录成功时调用history.back()，试图回到登录前的页面。这是一种错误的方法。
	任何情况，你都不应该使用history这个对象了。

	(
		console.log(location.port);  //'' 是应为80端口可以省略
		
		廖老师，你第一句里面“内部宽高是指除去菜单栏、工具栏、边框等占位元素后，用于显示网页的净宽高”
		我查了MDN和自己测试了，不是网页净宽高，而是会包括滚动条的
		
		包括滚动条就对了，滚动条本来就属于内部的内容
		
		我在最近做手机浏览器中网站的时候左上方的返回按钮用的都是history.back();感觉还是蛮有用的，为什么不推荐history了呢，会有什么问题呢，求大大解答
		
		不推荐，你做个用户登录，登录成功后back()又回到登录页了
		
		前后页面不涉及表单提交的操作的话，用back()问题也不是太大。
		
		如果不用history那么是用什么方案代替呢？
		
		不推荐用，但是如果对页面操作流程无影响的话还是可以用的。但是一定要注意在某些情况下，比如表单提交后，或者某个页面需要通过邮件发送给其他人查看的话，用history.back()是有问题的。
		
		假设从“个人中心”页跳转到“登录”，如果登录成功之后用 "history.back()"的话会回到“个人中心”页面，但是登录成功的信息并不会返回过来，所以不推荐使用。
		当然，就登录案例而言的话，可以在“登录”页面写返回代码之前加上一个让“个人中心”页面能监听的方法名。 然后返回到“个人中心”页面之后，当JS监听到了这个方法，就去刷新数据或是接数据等等操作。
		
		不推荐history，那有没有替代方案啊？
		
		用document.referrer前向地址应该可以代替back
		
		referer是防盗链，refresh是定时刷新，请求头和相应头
	)

	由于HTML文档被浏览器解析后就是一棵DOM树，要改变HTML的结构，就需要通过JavaScript来操作DOM。

	始终记住DOM是一个树形结构。操作一个DOM节点实际上就是这么几个操作：

	更新：更新该DOM节点的内容，相当于更新了该DOM节点表示的HTML的内容；

	遍历：遍历该DOM节点下的子节点，以便进行进一步操作；

	添加：在该DOM节点下新增一个子节点，相当于动态增加了一个HTML节点；

	删除：将该节点从HTML中删除，相当于删掉了该DOM节点的内容以及它包含的所有子节点。

	在操作一个DOM节点前，我们需要通过各种方式先拿到这个DOM节点。最常用的方法是document.getElementById()和document.getElementsByTagName()，以及CSS选择器document.getElementsByClassName()。

	由于ID在HTML文档中是唯一的，所以document.getElementById()可以直接定位唯一的一个DOM节点。document.getElementsByTagName()和document.getElementsByClassName()总是返回一组DOM节点。要精确地选择DOM，可以先定位父节点，再从父节点开始选择，以缩小范围。
	
	// 返回ID为'test'的节点：
	var test = document.getElementById('test');

	// 先定位ID为'test-table'的节点，再返回其内部所有tr节点：
	var trs = document.getElementById('test-table').getElementsByTagName('tr');

	// 先定位ID为'test-div'的节点，再返回其内部所有class包含red的节点：
	var reds = document.getElementById('test-div').getElementsByClassName('red');

	// 获取节点test下的所有直属子节点:
	var cs = test.children;

	// 获取节点test下第一个、最后一个子节点：
	var first = test.firstElementChild;
	var last = test.lastElementChild;

	第二种方法是使用querySelector()和querySelectorAll()，需要了解selector语法，然后使用条件来获取节点，更加方便：
	// 通过querySelector获取ID为q1的节点：
	var q1 = document.querySelector('#q1');

	// 通过querySelectorAll获取q1节点内的符合条件的所有节点：
	var ps = q1.querySelectorAll('div.highlighted > p');
	注意：低版本的IE<8不支持querySelector和querySelectorAll。IE8仅有限支持。
	
	严格地讲，我们这里的DOM节点是指Element，但是DOM节点实际上是Node，在HTML中，Node包括Element、Comment、CDATA_SECTION等很多种，以及根节点Document类型，但是，绝大多数时候我们只关心Element，也就是实际控制页面结构的Node，其他类型的Node忽略即可。根节点Document已经自动绑定为全局变量document。
	
	拿到一个DOM节点后，我们可以对它进行更新。

	可以直接修改节点的文本，方法有两种：

	一种是修改innerHTML属性，这个方式非常强大，不但可以修改一个DOM节点的文本内容，还可以直接通过HTML片段修改DOM节点内部的子树：

	// 获取<p id="p-id">...</p>
	var p = document.getElementById('p-id');
	// 设置文本为abc:
	p.innerHTML = 'ABC'; // <p id="p-id">ABC</p>
	// 设置HTML:
	p.innerHTML = 'ABC <span style="color:red">RED</span> XYZ';
	// <p>...</p>的内部结构已修改
	
	用innerHTML时要注意，是否需要写入HTML。如果写入的字符串是通过网络拿到了，要注意对字符编码来避免XSS攻击。
	
	第二种是修改innerText或textContent属性，这样可以自动对字符串进行HTML编码，保证无法设置任何HTML标签：

	// 获取<p id="p-id">...</p>
	var p = document.getElementById('p-id');
	// 设置文本:
	p.innerText = '<script>alert("Hi")</script>';
	// HTML被自动编码，无法设置一个<script>节点:
	// <p id="p-id">&lt;script&gt;alert("Hi")&lt;/script&gt;</p>
	两者的区别在于读取属性时，innerText不返回隐藏元素的文本，而textContent返回所有文本。另外注意IE<9不支持textContent。

	修改CSS也是经常需要的操作。DOM节点的style属性对应所有的CSS，可以直接获取或设置。因为CSS允许font-size这样的名称，但它并非JavaScript有效的属性名，所以需要在JavaScript中改写为驼峰式命名fontSize：

	// 获取<p id="p-id">...</p>
	var p = document.getElementById('p-id');
	// 设置CSS:
	p.style.color = '#ff0000';
	p.style.fontSize = '20px';
	p.style.paddingTop = '2em';

	当我们获得了某个DOM节点，想在这个DOM节点内插入新的DOM，应该如何做？

	如果这个DOM节点是空的，例如，<div></div>，那么，直接使用innerHTML = '<span>child</span>'就可以修改DOM节点的内容，相当于“插入”了新的DOM节点。

	如果这个DOM节点不是空的，那就不能这么做，因为innerHTML会直接替换掉原来的所有子节点。

	有两个办法可以插入新的节点。一个是使用appendChild，把一个子节点添加到父节点的最后一个子节点。例如：

	<!-- HTML结构 -->
	<p id="js">JavaScript</p>
	<div id="list">
		<p id="java">Java</p>
		<p id="python">Python</p>
		<p id="scheme">Scheme</p>
	</div>
	把<p id="js">JavaScript</p>添加到<div id="list">的最后一项：

	var
		js = document.getElementById('js'),
		list = document.getElementById('list');
	list.appendChild(js);
	现在，HTML结构变成了这样：

	<!-- HTML结构 -->
	<div id="list">
		<p id="java">Java</p>
		<p id="python">Python</p>
		<p id="scheme">Scheme</p>
		<p id="js">JavaScript</p>
	</div>
	因为我们插入的js节点已经存在于当前的文档树，因此这个节点首先会从原先的位置删除，再插入到新的位置。

	更多的时候我们会从零创建一个新的节点，然后插入到指定位置：

	var
		list = document.getElementById('list'),
		haskell = document.createElement('p');
	haskell.id = 'haskell';
	haskell.innerText = 'Haskell';
	list.appendChild(haskell);
	这样我们就动态添加了一个新的节点：

	<!-- HTML结构 -->
	<div id="list">
		<p id="java">Java</p>
		<p id="python">Python</p>
		<p id="scheme">Scheme</p>
		<p id="haskell">Haskell</p>
	</div>
	动态创建一个节点然后添加到DOM树中，可以实现很多功能。举个例子，下面的代码动态创建了一个<style>节点，然后把它添加到<head>节点的末尾，这样就动态地给文档添加了新的CSS定义：

	var d = document.createElement('style');
	d.setAttribute('type', 'text/css');
	d.innerHTML = 'p { color: red }';
	document.getElementsByTagName('head')[0].appendChild(d);
	可以在Chrome的控制台执行上述代码，观察页面样式的变化。

	insertBefore
	如果我们要把子节点插入到指定的位置怎么办？可以使用parentElement.insertBefore(newElement, referenceElement);，子节点会插入到referenceElement之前。

	还是以上面的HTML为例，假定我们要把Haskell插入到Python之前：

	<!-- HTML结构 -->
	<div id="list">
		<p id="java">Java</p>
		<p id="python">Python</p>
		<p id="scheme">Scheme</p>
	</div>
	可以这么写：

	var
		list = document.getElementById('list'),
		ref = document.getElementById('python'),
		haskell = document.createElement('p');
	haskell.id = 'haskell';
	haskell.innerText = 'Haskell';
	list.insertBefore(haskell, ref);
	新的HTML结构如下：

	<!-- HTML结构 -->
	<div id="list">
		<p id="java">Java</p>
		<p id="haskell">Haskell</p>
		<p id="python">Python</p>
		<p id="scheme">Scheme</p>
	</div>
	可见，使用insertBefore重点是要拿到一个“参考子节点”的引用。很多时候，需要循环一个父节点的所有子节点，可以通过迭代children属性实现：

	var
		i, c,
		list = document.getElementById('list');
	for (i = 0; i < list.children.length; i++) {
		c = list.children[i]; // 拿到第i个子节点
	}
	
	删除一个DOM节点就比插入要容易得多。

	要删除一个节点，首先要获得该节点本身以及它的父节点，然后，调用父节点的removeChild把自己删掉：

	// 拿到待删除节点:
	var self = document.getElementById('to-be-removed');
	// 拿到父节点:
	var parent = self.parentElement;
	// 删除:
	var removed = parent.removeChild(self);
	removed === self; // true
	注意到删除后的节点虽然不在文档树中了，但其实它还在内存中，可以随时再次被添加到别的位置。

	当你遍历一个父节点的子节点并进行删除操作时，要注意，children属性是一个只读属性，并且它在子节点变化时会实时更新。

	例如，对于如下HTML结构：

	<div id="parent">
		<p>First</p>
		<p>Second</p>
	</div>
	当我们用如下代码删除子节点时：

	var parent = document.getElementById('parent');
	parent.removeChild(parent.children[0]);
	parent.removeChild(parent.children[1]); // <-- 浏览器报错
	浏览器报错：parent.children[1]不是一个有效的节点。原因就在于，当<p>First</p>节点被删除后，parent.children的节点数量已经从2变为了1，索引[1]已经不存在了。

	因此，删除多个节点时，要注意children属性时刻都在变化。
	
	如果我们获得了一个<input>节点的引用，就可以直接调用value获得对应的用户输入值：
	// <input type="text" id="email">
	var input = document.getElementById('email');
	input.value; // '用户输入的值'
	这种方式可以应用于text、password、hidden以及select
	
	对于单选框和复选框，value属性返回的永远是HTML预设的值，而我们需要获得的实际是用户是否“勾上了”选项，所以应该用checked判断：
	// <label><input type="radio" name="weekday" id="monday" value="1"> Monday</label>
	// <label><input type="radio" name="weekday" id="tuesday" value="2"> Tuesday</label>
	var mon = document.getElementById('monday');
	var tue = document.getElementById('tuesday');
	mon.value; // '1'
	tue.value; // '2'
	mon.checked; // true或者false
	tue.checked; // true或者false
		
	设置值和获取值类似，对于text、password、hidden以及select，直接设置value就可以：

	// <input type="text" id="email">
	var input = document.getElementById('email');
	input.value = 'test@example.com'; // 文本框的内容已更新
	对于单选框和复选框，设置checked为true或false即可。

	HTML5新增了大量标准控件，常用的包括date、datetime、datetime-local、color等，它们都使用<input>标签：
	<input type="date" value="2015-07-01">
	<input type="datetime-local" value="2015-07-01T02:03:04">
	<input type="color" value="#ff0000">
	
	不支持HTML5的浏览器无法识别新的控件，会把它们当做type="text"来显示。支持HTML5的浏览器将获得格式化的字符串。例如，type="date"类型的input的value将保证是一个有效的YYYY-MM-DD格式的日期，或者空字符串。
	
	JavaScript可以以两种方式来处理表单的提交（AJAX方式在后面介绍）
	
	方式一是通过<form>元素的submit()方法提交一个表单，例如，响应一个<button>的click事件，在JavaScript代码中提交表单：
	<!-- HTML -->
	<form id="test-form">
		<input type="text" name="test">
		<button type="button" onclick="doSubmitForm()">Submit</button>
	</form>
	<script>
	function doSubmitForm() {
		var form = document.getElementById('test-form');
		// 可以在此修改form的input...
		// 提交form:
		form.submit();
	}
	</script>
	
	这种方式的缺点是扰乱了浏览器对form的正常提交。浏览器默认点击<button type="submit">时提交表单，或者用户在最后一个输入框按回车键。因此，第二种方式是响应<form>本身的onsubmit事件，在提交form时作修改：
	<!-- HTML -->
	<form id="test-form" onsubmit="return checkForm()">
		<input type="text" name="test">
		<button type="submit">Submit</button>
	</form>
	<script>
	function checkForm() {
		var form = document.getElementById('test-form');
		// 可以在此修改form的input...
		// 继续下一步:
		return true;
	}
	</script>
	
	注意要return true来告诉浏览器继续提交，如果return false，浏览器将不会继续提交form，这种情况通常对应用户输入有误，提示用户错误信息后终止提交form。
	
	在检查和修改<input>时，要充分利用<input type="hidden">来传递数据。

	例如，很多登录表单希望用户输入用户名和口令，但是，安全考虑，提交表单时不传输明文口令，而是口令的MD5。普通JavaScript开发人员会直接修改<input>：
	<!-- HTML -->
	<form id="login-form" method="post" onsubmit="return checkForm()">
		<input type="text" id="username" name="username">
		<input type="password" id="password" name="password">
		<button type="submit">Submit</button>
	</form>
	<script>
	function checkForm() {
		var pwd = document.getElementById('password');
		// 把用户输入的明文变为MD5:
		pwd.value = toMD5(pwd.value);
		// 继续下一步:
		return true;
	}
	</script>
	
	这个做法看上去没啥问题，但用户输入了口令提交时，口令框的显示会突然从几个*变成32个*（因为MD5有32个字符）。
	
	要想不改变用户的输入，可以利用<input type="hidden">实现：
	<!-- HTML -->
	<form id="login-form" method="post" onsubmit="return checkForm()">
		<input type="text" id="username" name="username">
		<input type="password" id="input-password">
		<input type="hidden" id="md5-password" name="password">
		<button type="submit">Submit</button>
	</form>
	<script>
	function checkForm() {
		var input_pwd = document.getElementById('input-password');
		var md5_pwd = document.getElementById('md5-password');
		// 把用户输入的明文变为MD5:
		md5_pwd.value = toMD5(input_pwd.value);
		// 继续下一步:
		return true;
	}
	</script>
	
	注意到id为md5-password的<input>标记了name="password"，而用户输入的id为input-password的<input>没有name属性。没有name属性的<input>的数据不会被提交。
	
	在HTML表单中，可以上传文件的唯一控件就是<input type="file">。

	注意：当一个表单包含<input type="file">时，表单的enctype必须指定为multipart/form-data，method必须指定为post，浏览器才能正确编码并以multipart/form-data格式发送表单的数据。
	
	出于安全考虑，浏览器只允许用户点击<input type="file">来选择本地文件，用JavaScript对<input type="file">的value赋值是没有任何效果的。当用户选择了上传某个文件后，JavaScript也无法获得该文件的真实路径
	
	通常，上传的文件都由后台服务器处理，JavaScript可以在提交表单时对文件扩展名做检查，以便防止用户上传无效格式的文件：
	var f = document.getElementById('test-file-upload');
	var filename = f.value; // 'C:\fakepath\test.png'
	if (!filename || !(filename.endsWith('.jpg') || filename.endsWith('.png') || filename.endsWith('.gif'))) {
		alert('Can only upload image file.');
		return false;
	}
	
	由于JavaScript对用户上传的文件操作非常有限，尤其是无法读取文件内容，使得很多需要操作文件的网页不得不用Flash这样的第三方插件来实现。
	随着HTML5的普及，新增的File API允许JavaScript读取文件内容，获得更多的文件信息。
	HTML5的File API提供了File和FileReader两个主要对象，可以获得文件信息并读取文件。
			
	下面的例子演示了如何读取用户选取的图片文件，并在一个<div>中预览图像：
	var
		fileInput = document.getElementById('test-image-file'),
		info = document.getElementById('test-file-info'),
		preview = document.getElementById('test-image-preview');
	// 监听change事件:
	fileInput.addEventListener('change', function () {
		// 清除背景图片:
		preview.style.backgroundImage = '';
		// 检查文件是否选择:
		if (!fileInput.value) {
			info.innerHTML = '没有选择文件';
			return;
		}
		// 获取File引用:
		var file = fileInput.files[0];
		// 获取File信息:
		info.innerHTML = '文件: ' + file.name + '<br>' +
						 '大小: ' + file.size + '<br>' +
						 '修改: ' + file.lastModifiedDate;
		if (file.type !== 'image/jpeg' && file.type !== 'image/png' && file.type !== 'image/gif') {
			alert('不是有效的图片文件!');
			return;
		}
		// 读取文件:
		var reader = new FileReader();
		reader.onload = function(e) {
			var
				data = e.target.result; // 'data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...'            
			preview.style.backgroundImage = 'url(' + data + ')';
		};
		// 以DataURL的形式读取文件:
		reader.readAsDataURL(file);
	});
	
	上面的代码演示了如何通过HTML5的File API读取文件内容。以DataURL的形式读取到的文件是一个字符串，类似于data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...，常用于设置图像。如果需要服务器端处理，把字符串base64,后面的字符发送给服务器并用Base64解码就可以得到原始文件的二进制内容。
	
	上面的代码还演示了JavaScript的一个重要的特性就是单线程执行模式。在JavaScript中，浏览器的JavaScript执行引擎在执行JavaScript代码时，总是以单线程模式执行，也就是说，任何时候，JavaScript代码都不可能同时有多于1个线程在执行。
	
	你可能会问，单线程模式执行的JavaScript，如何处理多任务？
	在JavaScript中，执行多任务实际上都是异步调用，比如上面的代码：
	reader.readAsDataURL(file);
	就会发起一个异步操作来读取文件内容。因为是异步操作，所以我们在JavaScript代码中就不知道什么时候操作结束，因此需要先设置一个回调函数：
	reader.onload = function(e) {
		// 当文件读取完成后，自动调用此函数:
	};
	当文件读取完成后，JavaScript引擎将自动调用我们设置的回调函数。执行回调函数时，文件已经读取完毕，所以我们可以在回调函数内部安全地获得文件内容。
	
	(
		reader.onload = function(e) 这个参数e，理解不能。因为change事件所监听的function ()这个外层函数是无参数的。怎样才能向内层的(e)传递参数呢。
		
		你这里弄错了函数了。 在实例代码中，最后传入参数e的是回调函数reader.onload :
		reader.onload = function (e) { ... }
		而change事件则是通过添加监听事件来捕获：
		// 监听change事件:
		fileInput.addEventListener('change', function () { ... }
		
		层主想表达的是onload事件的参数e(vent)是否从onchange事件外部传递进来，如果是，那么在示例中并onchange函数并没有传进来任何参数，那么参数e是怎么来的。
		其实，onchange, onload等事件是通过回调的方式执行的，首先是<a href='https://www.w3school.com.cn/jsref/dom_obj_event.asp'>HTML DOM Event 对象</a>分发事件句柄(event handlers)给可能需要执行的函数，当某个事件被触发(fire)时，句柄执行对应元素的onload等事件定义函数。
		但是如果需要获得event对象所存储的状态（例如获取调用onload事件的元素）,那么可以通过event.target（例子中的e.target）来获得，这个event就是回调参数，实际上引用的是DOM Event对象，处在dom树的顶层。
		而依照程序执行状况来看，这个回调参数Event是在addListener函数中处理传入，所以onchange事件被触发时也已经一并传入了Event对象实例，change事件中的function () {}参数列表为空是表示没有用户自定义参数！
		如果上述观点有错误，欢迎大家指正！
		
		因为浏览器是按顺序解析 html 的，而 script 标签在 input 标签之前，运行 script 的代码时，DOM 树中还没有生成 div 和 input 元素，所以在 js 中获取不了这些元素。用 window.onload() 包含整个 js 代码就可以了。
	)
	
	
	AJAX不是JavaScript的规范，它只是一个哥们“发明”的缩写：Asynchronous JavaScript and XML，意思就是用JavaScript执行异步网络请求。

	如果仔细观察一个Form的提交，你就会发现，一旦用户点击“Submit”按钮，表单开始提交，浏览器就会刷新页面，然后在新页面里告诉你操作是成功了还是失败了。如果不幸由于网络太慢或者其他原因，就会得到一个404页面。

	这就是Web的运作原理：一次HTTP请求对应一个页面。

	如果要让用户留在当前页面中，同时发出新的HTTP请求，就必须用JavaScript发送这个新请求，接收到数据后，再用JavaScript更新页面，这样一来，用户就感觉自己仍然停留在当前页面，但是数据却可以不断地更新。

	最早大规模使用AJAX的就是Gmail，Gmail的页面在首次加载后，剩下的所有数据都依赖于AJAX来更新。

	用JavaScript写一个完整的AJAX代码并不复杂，但是需要注意：AJAX请求是异步执行的，也就是说，要通过回调函数获得响应。

	在现代浏览器上写AJAX主要依靠XMLHttpRequest对象：
	'use strict';
	function success(text) {
		var textarea = document.getElementById('test-response-text');
		textarea.value = text;
	}
	function fail(code) {
		var textarea = document.getElementById('test-response-text');
		textarea.value = 'Error code: ' + code;
	}
	var request = new XMLHttpRequest(); // 新建XMLHttpRequest对象
	request.onreadystatechange = function () { // 状态发生变化时，函数被回调
		if (request.readyState === 4) { // 成功完成
			// 判断响应结果:
			if (request.status === 200) {
				// 成功，通过responseText拿到响应的文本:
				return success(request.responseText);
			} else {
				// 失败，根据响应码判断失败原因:
				return fail(request.status);
			}
		} else {
			// HTTP请求还在继续...
		}
	}
	// 发送请求:
	request.open('GET', '/api/categories');
	request.send();
	alert('请求已发送，请等待响应...');
	
	对于低版本的IE，需要换一个ActiveXObject对象：
	'use strict'
	function success(text) {
		var textarea = document.getElementById('test-ie-response-text');
		textarea.value = text;
	}
	function fail(code) {
		var textarea = document.getElementById('test-ie-response-text');
		textarea.value = 'Error code: ' + code;
	}
	var request = new ActiveXObject('Microsoft.XMLHTTP'); // 新建Microsoft.XMLHTTP对象
	request.onreadystatechange = function () { // 状态发生变化时，函数被回调
		if (request.readyState === 4) { // 成功完成
			// 判断响应结果:
			if (request.status === 200) {
				// 成功，通过responseText拿到响应的文本:
				return success(request.responseText);
			} else {
				// 失败，根据响应码判断失败原因:
				return fail(request.status);
			}
		} else {
			// HTTP请求还在继续...
		}
	}
	// 发送请求:
	request.open('GET', '/api/categories');
	request.send();
	alert('请求已发送，请等待响应...');

	如果你想把标准写法和IE写法混在一起，可以这么写：
	var request;
	if (window.XMLHttpRequest) {
		request = new XMLHttpRequest();
	} else {
		request = new ActiveXObject('Microsoft.XMLHTTP');
	}
	
	通过检测window对象是否有XMLHttpRequest属性来确定浏览器是否支持标准的XMLHttpRequest。注意，不要根据浏览器的navigator.userAgent来检测浏览器是否支持某个JavaScript特性，一是因为这个字符串本身可以伪造，二是通过IE版本判断JavaScript特性将非常复杂。

	当创建了XMLHttpRequest对象后，要先设置onreadystatechange的回调函数。在回调函数中，通常我们只需通过readyState === 4判断请求是否完成，如果已完成，再根据status === 200判断是否是一个成功的响应。

	XMLHttpRequest对象的open()方法有3个参数，第一个参数指定是GET还是POST，第二个参数指定URL地址，第三个参数指定是否使用异步，默认是true，所以不用写。

	注意，千万不要把第三个参数指定为false，否则浏览器将停止响应，直到AJAX请求完成。如果这个请求耗时10秒，那么10秒内你会发现浏览器处于“假死”状态。

	最后调用send()方法才真正发送请求。GET请求不需要参数，POST请求需要把body部分以字符串或者FormData对象传进去。
			
	上面代码的URL使用的是相对路径。如果你把它改为'http://www.sina.com.cn/'，再运行，肯定报错。在Chrome的控制台里，还可以看到错误信息。

	这是因为浏览器的同源策略导致的。默认情况下，JavaScript在发送AJAX请求时，URL的域名必须和当前页面完全一致。

	完全一致的意思是，域名要相同（www.example.com和example.com不同），协议要相同（http和https不同），端口号要相同（默认是:80端口，它和:8080就不同）。有的浏览器口子松一点，允许端口不同，大多数浏览器都会严格遵守这个限制。

	那是不是用JavaScript无法请求外域（就是其他网站）的URL了呢？方法还是有的，大概有这么几种：

	一是通过Flash插件发送HTTP请求，这种方式可以绕过浏览器的安全限制，但必须安装Flash，并且跟Flash交互。不过Flash用起来麻烦，而且现在用得也越来越少了。
	
	二是通过在同源域名下架设一个代理服务器来转发，JavaScript负责把请求发送到代理服务器：

	'/proxy?url=http://www.sina.com.cn'
	代理服务器再把结果返回，这样就遵守了浏览器的同源策略。这种方式麻烦之处在于需要服务器端额外做开发。
			
	第三种方式称为JSONP，它有个限制，只能用GET请求，并且要求返回JavaScript。这种方式跨域实际上是利用了浏览器允许跨域引用JavaScript资源：
	<html>
	<head>
		<script src="http://example.com/abc.js"></script>
		...
	</head>
	<body>
	...
	</body>
	</html>
	
	JSONP通常以函数调用的形式返回，例如，返回JavaScript内容如下：
	foo('data');
	这样一来，我们如果在页面中先准备好foo()函数，然后给页面动态加一个<script>节点，相当于动态读取外域的JavaScript资源，最后就等着接收回调了。		
			
	如果浏览器支持HTML5，那么就可以一劳永逸地使用新的跨域策略：CORS了。

	CORS全称Cross-Origin Resource Sharing，是HTML5规范定义的如何跨域访问资源。

	了解CORS前，我们先搞明白概念：

	Origin表示本域，也就是浏览器当前页面的域。当JavaScript向外域（如sina.com）发起请求后，浏览器收到响应后，首先检查Access-Control-Allow-Origin是否包含本域，如果是，则此次跨域请求成功，如果不是，则请求失败，JavaScript将无法获取到响应的任何数据。

	用一个图来表示就是：https://static.liaoxuefeng.com/files/attachments/1027024093709472/l
	
	假设本域是my.com，外域是sina.com，只要响应头Access-Control-Allow-Origin为http://my.com，或者是*，本次请求就可以成功。

	可见，跨域能否成功，取决于对方服务器是否愿意给你设置一个正确的Access-Control-Allow-Origin，决定权始终在对方手中。
	
	假设本域是my.com，外域是sina.com，只要响应头Access-Control-Allow-Origin为http://my.com，或者是*，本次请求就可以成功。

	可见，跨域能否成功，取决于对方服务器是否愿意给你设置一个正确的Access-Control-Allow-Origin，决定权始终在对方手中。

	上面这种跨域请求，称之为“简单请求”。简单请求包括GET、HEAD和POST（POST的Content-Type类型 仅限application/x-www-form-urlencoded、multipart/form-data和text/plain），并且不能出现任何自定义头（例如，X-Custom: 12345），通常能满足90%的需求。

	无论你是否需要用JavaScript通过CORS跨域请求资源，你都要了解CORS的原理。最新的浏览器全面支持HTML5。在引用外域资源时，除了JavaScript和CSS外，都要验证CORS。例如，当你引用了某个第三方CDN上的字体文件时：

	/* CSS */
	@font-face {
	  font-family: 'FontAwesome';
	  src: url('http://cdn.com/fonts/fontawesome.ttf') format('truetype');
	}
	
	如果该CDN服务商未正确设置Access-Control-Allow-Origin，那么浏览器无法加载字体资源。
	
	对于PUT、DELETE以及其他类型如application/json的POST请求，在发送AJAX请求之前，浏览器会先发送一个OPTIONS请求（称为preflighted请求）到这个URL上，询问目标服务器是否接受：

	OPTIONS /path/to/resource HTTP/1.1
	Host: bar.com
	Origin: http://my.com
	Access-Control-Request-Method: POST

	服务器必须响应并明确指出允许的Method：

	HTTP/1.1 200 OK
	Access-Control-Allow-Origin: http://my.com
	Access-Control-Allow-Methods: POST, GET, PUT, OPTIONS
	Access-Control-Max-Age: 86400
	
	浏览器确认服务器响应的Access-Control-Allow-Methods头确实包含将要发送的AJAX请求的Method，才会继续发送AJAX，否则，抛出一个错误。

	由于以POST、PUT方式传送JSON格式的数据在REST中很常见，所以要跨域正确处理POST和PUT请求，服务器端必须正确响应OPTIONS请求。
	
	(
		7年多前的文章，如今读来还是比很多同类型的文章容易理解，步骤：

		1、一个众所周知的问题，Ajax直接请求普通文件存在跨域无权限访问的问题，甭管你是静态页面、动态网页、web服务、WCF，只要是跨域请求，一律不准；
		2、不过我们又发现，Web页面上调用js文件时则不受是否跨域的影响（不仅如此，我们还发现凡是拥有"src"这个属性的标签都拥有跨域的能力，比如<script>、<img>、<iframe>）；
		3、于是可以判断，当前阶段如果想通过纯web端（ActiveX控件、服务端代理、属于未来的HTML5之Websocket等方式不算）跨域访问数据就只有一种可能，那就是在远程服务器上设法把数据装进js格式的文件里，供客户端调用和进一步处理；
		4、恰巧我们已经知道有一种叫做JSON的纯字符数据格式可以简洁的描述复杂数据，更妙的是JSON还被js原生支持，所以在客户端几乎可以随心所欲的处理这种格式的数据；
		5、这样子解决方案就呼之欲出了，web客户端通过与调用脚本一模一样的方式，来调用跨域服务器上动态生成的js格式文件（一般以JSON为后缀），显而易见，服务器之所以要动态生成JSON文件，目的就在于把客户端需要的数据装入进去。
		6、客户端在对JSON文件调用成功之后，也就获得了自己所需的数据，剩下的就是按照自己需求进行处理和展现了，这种获取远程数据的方式看起来非常像AJAX，但其实并不一样。
		7、为了便于客户端使用数据，逐渐形成了一种非正式传输协议，人们把它称作JSONP，该协议的一个要点就是允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。
		<a href='https://www.cnblogs.com/dowinning/archive/2012/04/19/json-jsonp-jquery.html'>https://www.cnblogs.com/dowinning/archive/2012/04/19/json-jsonp-jquery.html</a>
	
		关于跨域，反向代理跨域，jsonp等方式，一直觉着很混乱。不知哪种才算更优雅。
		
		一般来说，如果开发API的是自己人的话，让他直接设置CORS就可以了。（我现在项目就是前后端分离，后台就是这样设置。） 如果要请求的API不在自己控制的话，如果对方提供了JSONP（像豆瓣那样的），可以使用JSONP。 最后如果是对方没有提供JSONP，前端又需要用到那方面的API的话，那就需要搭建发现代理服务器咯。 其实我比较倾向于搭建代理服务器~
	)
	
	在JavaScript的世界中，所有代码都是单线程执行的。
	
	由于这个“缺陷”，导致JavaScript的所有网络操作，浏览器事件，都必须是异步执行。异步执行可以用回调函数实现：
	function callback() {
		console.log('Done');
	}
	console.log('before setTimeout()');
	setTimeout(callback, 1000); // 1秒钟后调用callback函数
	console.log('after setTimeout()');
	
	观察上述代码执行，在Chrome的控制台输出可以看到：
	before setTimeout()
	after setTimeout()
	(等待1秒后)
	Done
	
	可见，异步操作会在将来的某个时间点触发一个函数调用。

	AJAX就是典型的异步操作。以上一节的代码为例：

	request.onreadystatechange = function () {
		if (request.readyState === 4) {
			if (request.status === 200) {
				return success(request.responseText);
			} else {
				return fail(request.status);
			}
		}
	}
	
	把回调函数success(request.responseText)和fail(request.status)写到一个AJAX操作里很正常，但是不好看，而且不利于代码复用。
	
	有没有更好的写法？比如写成这样：

	var ajax = ajaxGet('http://...');
	ajax.ifSuccess(success)
		.ifFail(fail);
	
	这种链式写法的好处在于，先统一执行AJAX逻辑，不关心如何处理结果，然后，根据结果是成功还是失败，在将来的某个时候调用success函数或fail函数。

	古人云：“君子一诺千金”，这种“承诺将来会执行”的对象在JavaScript中称为Promise对象。
	
	Promise有各种开源实现，在ES6中被统一规范，由浏览器直接支持。先测试一下你的浏览器是否支持Promise：
	'use strict';
	new Promise(function () {});
	
	我们先看一个最简单的Promise例子：生成一个0-2之间的随机数，如果小于1，则等待一段时间后返回成功，否则返回失败：
	function test(resolve, reject) {
		var timeOut = Math.random() * 2;
		log('set timeout to: ' + timeOut + ' seconds.');
		setTimeout(function () {
			if (timeOut < 1) {
				log('call resolve()...');
				resolve('200 OK');
			}
			else {
				log('call reject()...');
				reject('timeout in ' + timeOut + ' seconds.');
			}
		}, timeOut * 1000);
	}
	
	这个test()函数有两个参数，这两个参数都是函数，如果执行成功，我们将调用resolve('200 OK')，如果执行失败，我们将调用reject('timeout in ' + timeOut + ' seconds.')。可以看出，test()函数只关心自身的逻辑，并不关心具体的resolve和reject将如何处理结果。
	
	有了执行函数，我们就可以用一个Promise对象来执行它，并在将来某个时刻获得成功或失败的结果：
	var p1 = new Promise(test);
	var p2 = p1.then(function (result) {
		console.log('成功：' + result);
	});
	var p3 = p2.catch(function (reason) {
		console.log('失败：' + reason);
	});
	
	变量p1是一个Promise对象，它负责执行test函数。由于test函数在内部是异步执行的，当test函数执行成功时，我们告诉Promise对象：
	// 如果成功，执行这个函数：
	p1.then(function (result) {
		console.log('成功：' + result);
	});
	
	当test函数执行失败时，我们告诉Promise对象：
	p2.catch(function (reason) {
		console.log('失败：' + reason);
	});
	
	Promise对象可以串联起来，所以上述代码可以简化为：
	new Promise(test).then(function (result) {
		console.log('成功：' + result);
	}).catch(function (reason) {
		console.log('失败：' + reason);
	});
	
	实际测试一下，看看Promise是如何异步执行的：
	'use strict';
	// 清除log:
	var logging = document.getElementById('test-promise-log');
	while (logging.children.length > 1) {
		logging.removeChild(logging.children[logging.children.length - 1]);
	}
	// 输出log到页面:
	function log(s) {
		var p = document.createElement('p');
		p.innerHTML = s;
		logging.appendChild(p);
	}
	new Promise(function (resolve, reject) {
		log('start new Promise...');
		var timeOut = Math.random() * 2;
		log('set timeout to: ' + timeOut + ' seconds.');
		setTimeout(function () {
			if (timeOut < 1) {
				log('call resolve()...');
				resolve('200 OK');
			}
			else {
				log('call reject()...');
				reject('timeout in ' + timeOut + ' seconds.');
			}
		}, timeOut * 1000);
	}).then(function (r) {
		log('Done: ' + r);
	}).catch(function (reason) {
		log('Failed: ' + reason);
	});
	
	可见Promise最大的好处是在异步执行的流程中，把执行代码和处理结果的代码清晰地分离了：
	https://static.liaoxuefeng.com/files/attachments/1027242914217888/l
	
	Promise还可以做更多的事情，比如，有若干个异步任务，需要先做任务1，如果成功后再做任务2，任何任务失败则不再继续并执行错误处理函数。

	要串行执行这样的异步任务，不用Promise需要写一层一层的嵌套代码。有了Promise，我们只需要简单地写：
	job1.then(job2).then(job3).catch(handleError);
	其中，job1、job2和job3都是Promise对象。
	
	下面的例子演示了如何串行执行一系列需要异步计算获得结果的任务：
	'use strict';
	var logging = document.getElementById('test-promise2-log');
	while (logging.children.length > 1) {
		logging.removeChild(logging.children[logging.children.length - 1]);
	}
	function log(s) {
		var p = document.createElement('p');
		p.innerHTML = s;
		logging.appendChild(p);
	}
	
	// 0.5秒后返回input*input的计算结果:
	function multiply(input) {
		return new Promise(function (resolve, reject) {
			log('calculating ' + input + ' x ' + input + '...');
			setTimeout(resolve, 500, input * input);
		});
	}
	// 0.5秒后返回input+input的计算结果:
	function add(input) {
		return new Promise(function (resolve, reject) {
			log('calculating ' + input + ' + ' + input + '...');
			setTimeout(resolve, 500, input + input);
		});
	}
	var p = new Promise(function (resolve, reject) {
		log('start new Promise...');
		resolve(123);
	});
	p.then(multiply)
	 .then(add)
	 .then(multiply)
	 .then(add)
	 .then(function (result) {
		log('Got value: ' + result);
	});
	
	setTimeout可以看成一个模拟网络等异步执行的函数。现在，我们把上一节的AJAX异步执行函数转换为Promise对象，看看用Promise如何简化异步处理：
	'use strict';
	// ajax函数将返回Promise对象:
	function ajax(method, url, data) {
		var request = new XMLHttpRequest();
		return new Promise(function (resolve, reject) {
			request.onreadystatechange = function () {
				if (request.readyState === 4) {
					if (request.status === 200) {
						resolve(request.responseText);
					} else {
						reject(request.status);
					}
				}
			};
			request.open(method, url);
			request.send(data);
		});
	}
	var log = document.getElementById('test-promise-ajax-result');
	var p = ajax('GET', '/api/categories');
	p.then(function (text) { // 如果AJAX成功，获得响应内容
		log.innerText = text;
	}).catch(function (status) { // 如果AJAX失败，获得响应代码
		log.innerText = 'ERROR: ' + status;
	});
	
	除了串行执行若干异步任务外，Promise还可以并行执行异步任务。
	
	试想一个页面聊天系统，我们需要从两个不同的URL分别获得用户的个人信息和好友列表，这两个任务是可以并行执行的，用Promise.all()实现如下：
	var p1 = new Promise(function (resolve, reject) {
		setTimeout(resolve, 500, 'P1');
	});
	var p2 = new Promise(function (resolve, reject) {
		setTimeout(resolve, 600, 'P2');
	});
	// 同时执行p1和p2，并在它们都完成后执行then:
	Promise.all([p1, p2]).then(function (results) {
		console.log(results); // 获得一个Array: ['P1', 'P2']
	});
	
	有些时候，多个异步任务是为了容错。比如，同时向两个URL读取用户的个人信息，只需要获得先返回的结果即可。这种情况下，用Promise.race()实现：
	var p1 = new Promise(function (resolve, reject) {
		setTimeout(resolve, 500, 'P1');
	});
	var p2 = new Promise(function (resolve, reject) {
		setTimeout(resolve, 600, 'P2');
	});
	Promise.race([p1, p2]).then(function (result) {
		console.log(result); // 'P1'
	});
	
	由于p1执行较快，Promise的then()将获得结果'P1'。p2仍在继续执行，但执行结果将被丢弃。

	如果我们组合使用Promise，就可以把很多异步任务以并行和串行的方式组合起来执行。
	
	(
		Promise 不论成功或失败都会调用 then 然而catch() 只有当 promise 失败时才会调用
		所以当失败的时候既执行了then又执行了catch，只不过reject只会将参数传递给catch方法,并不传递then方法所以顺序写反失败后then就输出了undefined，而catch是正常输出结果

		我理解的不知道对不对：Promise构造对象之前执行传入的方法，会携带成功或失败后的信息，并将携带的信息传递给接下来执行的then方法或者catch方法。而Promise执行完then方法或catch方法之后返回的Promise对象不再携带处理成功或失败的结果了，所以你再次调用then方法，信息是undefined。你看接下来的示例，如果想连续使用then方法，你要重新构造Promise对象传入相应处理函数然后才能返回处理结果
		
		Promise().then().then....catch() 多任务串行执行.
		情景化记忆:在一个任务链中,比如我要向上级部门一层层的往上提交申请,if(某种条件)承诺帮你resolve解决问题,else承诺reject你的请求. 他给出的resolve问题的办法只是个空头Promise,then到总经理那实现具体承诺,如果总经理还是给一个空头承诺(返回Promise实例),还得then到董事长那里.... 任一一步做出的是reject的承诺,还有什么好说的,被拒绝了,后面的就不会再往上走了呀. 准备catch 拒绝通知吧blablabla
		Promise.all([p1,p2,...]) 多任务并行执行
		都要成功才进入then,返回结果数组.
		Promise.race([p1,p2,...]) 多任务赛跑.
		then()和catch(),谁先调用算谁的,其它任务中断.
		
		既然JS是单线程的，那是如何完成所谓的并行任务的呢?(以及Promise.all是如何实现并行执行的？)
		经找资料后自己的理解：JS引擎是单线程的，但是浏览器是多线程的，其执行的方法如setTimeOut是由浏览器来调度的，计时器也是一个单独的线程（并不是JS引擎来计时）。而Promise.all(iterable) 方法返回一个 Promise 实例,其内部方法串行执行，比如P1先计时完成，浏览器的触发线程就将P1方法放到JS队列中由JS引擎来执行。
	)
	
	Canvas是HTML5新增的组件，它就像一块幕布，可以用JavaScript在上面绘制各种图表、动画等。

	没有Canvas的年代，绘图只能借助Flash插件实现，页面不得不用JavaScript和Flash进行交互。有了Canvas，我们就再也不需要Flash了，直接使用JavaScript完成绘制。

	一个Canvas定义了一个指定尺寸的矩形框，在这个范围内我们可以随意绘制：
	<canvas id="test-canvas" width="300" height="200"></canvas>
	
	由于浏览器对HTML5标准支持不一致，所以，通常在<canvas>内部添加一些说明性HTML代码，如果浏览器支持Canvas，它将忽略<canvas>内部的HTML，如果浏览器不支持Canvas，它将显示<canvas>内部的HTML：
	<canvas id="test-stock" width="300" height="200">
		<p>Current Price: 25.51</p>
	</canvas>
	
	在使用Canvas前，用canvas.getContext来测试浏览器是否支持Canvas：
	<!-- HTML代码 -->
	<canvas id="test-canvas" width="200" heigth="100">
		<p>你的浏览器不支持Canvas</p>
	</canvas>
	'use strict';
	var canvas = document.getElementById('test-canvas');
	if (canvas.getContext) {
		console.log('你的浏览器支持Canvas!');
	} else {
		console.log('你的浏览器不支持Canvas!');
	}

	getContext('2d')方法让我们拿到一个CanvasRenderingContext2D对象，所有的绘图操作都需要通过这个对象完成。

	var ctx = canvas.getContext('2d');
	如果需要绘制3D怎么办？HTML5还有一个WebGL规范，允许在Canvas中绘制3D图形：

	gl = canvas.getContext("webgl");
	本节我们只专注于绘制2D图形。
	
	我们可以在Canvas上绘制各种形状。在绘制前，我们需要先了解一下Canvas的坐标系统：
	Canvas的坐标以左上角为原点，水平向右为X轴，垂直向下为Y轴，以像素为单位，所以每个点都是非负整数。
	
	CanvasRenderingContext2D对象有若干方法来绘制图形：
	'use strict';
	var canvas = document.getElementById('test-shape-canvas'),
        ctx = canvas.getContext('2d');
	ctx.clearRect(0, 0, 200, 200); // 擦除(0,0)位置大小为200x200的矩形，擦除的意思是把该区域变为透明
	ctx.fillStyle = '#dddddd'; // 设置颜色
	ctx.fillRect(10, 10, 130, 130); // 把(10,10)位置大小为130x130的矩形涂色
	// 利用Path绘制复杂路径:
	var path=new Path2D();
	path.arc(75, 75, 50, 0, Math.PI*2, true);
	path.moveTo(110,75);
	path.arc(75, 75, 35, 0, Math.PI, false);
	path.moveTo(65, 65);
	path.arc(60, 65, 5, 0, Math.PI*2, true);
	path.moveTo(95, 65);
	path.arc(90, 65, 5, 0, Math.PI*2, true);
	ctx.strokeStyle = '#0000ff';
	ctx.stroke(path);
	
	绘制文本就是在指定的位置输出文本，可以设置文本的字体、样式、阴影等，与CSS完全一致：

	'use strict';
	var canvas = document.getElementById('test-text-canvas'),
		ctx = canvas.getContext('2d');
	ctx.clearRect(0, 0, canvas.width, canvas.height);
	ctx.shadowOffsetX = 2;
	ctx.shadowOffsetY = 2;
	ctx.shadowBlur = 2;
	ctx.shadowColor = '#666666';
	ctx.font = '24px Arial';
	ctx.fillStyle = '#333333';
	ctx.fillText('带阴影的文字', 20, 40);
	
	Canvas除了能绘制基本的形状和文本，还可以实现动画、缩放、各种滤镜和像素转换等高级操作。如果要实现非常复杂的操作，考虑以下优化方案：
		通过创建一个不可见的Canvas来绘图，然后将最终绘制结果复制到页面的可见Canvas中；
		尽量使用整数坐标而不是浮点数；
		可以创建多个重叠的Canvas绘制不同的层，而不是在一个Canvas中绘制非常复杂的图；
		背景图片如果不变可以直接用<img>标签并放到最底层。
	
	请根据从163获取的JSON数据绘制最近30个交易日的K线图，数据已处理为包含一组对象的数组：
	'use strict';
	window.loadStockData = function (r) {
		var
			NUMS = 30,
			data = r.data;
		if (data.length > NUMS) {
			data = data.slice(data.length - NUMS);
		}
		data = data.map(function (x) {
			return {
				date: x[0],
				open: x[1],
				close: x[2],
				high: x[3],
				low: x[4],
				vol: x[5],
				change: x[6]
			};
		});
		window.drawStock(data);
	}
	window.drawStock = function (data) {
	    var canvas = document.getElementById('stock-canvas'),
            width = canvas.width,
            height = canvas.height,
            ctx = canvas.getContext('2d');
			console.log(JSON.stringify(data[0])); // {"date":"20150602","open":4844.7,"close":4910.53,"high":4911.57,"low":4797.55,"vol":62374809900,"change":1.69}
			ctx.clearRect(0, 0, width, height);
			ctx.fillText('Test Canvas', 10, 10);
	};
	// 加载最近30个交易日的K线图数据:
	var js = document.createElement('script');
	js.src = 'http://img1.money.126.net/data/hs/kline/day/history/2015/0000001.json?callback=loadStockData&t=' + Date.now();
	document.getElementsByTagName('head')[0].appendChild(js);
	
	
	
	
	
	
	



 



		
		
		
		参考资料： https://www.liaoxuefeng.com/wiki/1022910821149312
